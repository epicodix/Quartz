# Go ì–¸ì–´ ì˜ˆì œ 100ë¬¸í•­

## ë©”íƒ€ë°ì´í„°
- ì‘ì„±ì¼: 2024-11-15
- ì¹´í…Œê³ ë¦¬: #Goì–¸ì–´ #ì‹¤ìŠµ #ì˜ˆì œë¬¸ì œ
- íƒœê·¸: #golang #ì½”ë”©í…ŒìŠ¤íŠ¸ #ë¹ ë¥¸í•™ìŠµ
- ì—°ê´€: [[MIT_6824_ì£¼ë§_í•™ìŠµ_ê°€ì´ë“œ]]

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ
- Go ì–¸ì–´ ê¸°ì´ˆ ë¬¸ë²•ì„ **ì‹¤ìŠµìœ¼ë¡œ ì²´í™”**
- íŒŒì´ì¬ ê²½í—˜ìê°€ **ë¹ ë¥´ê²Œ Go íŒ¨í„´ ìµíˆê¸°**
- MIT 6.824 Lab ì¤€ë¹„ë¥¼ ìœ„í•œ **í•µì‹¬ ê°œë… ë§ˆìŠ¤í„°**

---

## ğŸ“š ë¬¸ì œ êµ¬ì„±
- **Level 1 (1-30)**: ê¸°ì´ˆ ë¬¸ë²•
- **Level 2 (31-60)**: í•¨ìˆ˜, êµ¬ì¡°ì²´, ì¸í„°í˜ì´ìŠ¤
- **Level 3 (61-85)**: ê³ ë£¨í‹´, ì±„ë„
- **Level 4 (86-100)**: ë„¤íŠ¸ì›Œí¬, ì‹¤ì „ ì‘ìš©

---

## Level 1: ê¸°ì´ˆ ë¬¸ë²• (1-30)

### 1-5: ë³€ìˆ˜ì™€ íƒ€ì…
```go
// 1. ì •ìˆ˜í˜• ë³€ìˆ˜ ì„ ì–¸í•˜ê³  ê°’ í• ë‹¹
package main
import "fmt"
func main() {
    // ì—¬ê¸°ì— ì½”ë“œ ì‘ì„±
}
```

**ë¬¸ì œ 1**: `age` ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  25ë¥¼ í• ë‹¹í•œ í›„ ì¶œë ¥í•˜ì„¸ìš”.
```go
// ë‹µì•ˆ
var age int = 25
fmt.Println(age)
```

**ë¬¸ì œ 2**: ì§§ì€ ì„ ì–¸ë¬¸ìœ¼ë¡œ `name`ì— "Alice" í• ë‹¹í•˜ê³  ì¶œë ¥í•˜ì„¸ìš”.
```go
// ë‹µì•ˆ
name := "Alice"
fmt.Println(name)
```

**ë¬¸ì œ 3**: `float64` íƒ€ì…ìœ¼ë¡œ ì›ì£¼ìœ¨ ê°’(3.14159)ì„ ì €ì¥í•˜ê³  ì¶œë ¥í•˜ì„¸ìš”.
```go
// ë‹µì•ˆ
var pi float64 = 3.14159
fmt.Println(pi)
```

**ë¬¸ì œ 4**: ì—¬ëŸ¬ ë³€ìˆ˜ë¥¼ í•œ ë²ˆì— ì„ ì–¸í•˜ì„¸ìš”. (ì´ë¦„, ë‚˜ì´, í‚¤)
```go
// ë‹µì•ˆ
var name, age, height = "Bob", 30, 175.5
fmt.Println(name, age, height)
```

**ë¬¸ì œ 5**: ìƒìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  ì‚¬ìš©í•˜ì„¸ìš”. (ì›ì˜ ë°˜ì§€ë¦„ 5)
```go
// ë‹µì•ˆ
const radius = 5
area := 3.14 * radius * radius
fmt.Println("ì›ì˜ ë„“ì´:", area)
```

### 6-10: ì¡°ê±´ë¬¸ê³¼ ë°˜ë³µë¬¸
**ë¬¸ì œ 6**: ìˆ«ìê°€ ì§ìˆ˜ì¸ì§€ í™€ìˆ˜ì¸ì§€ íŒë³„í•˜ì„¸ìš”.
```go
// ë‹µì•ˆ
num := 7
if num%2 == 0 {
    fmt.Println("ì§ìˆ˜")
} else {
    fmt.Println("í™€ìˆ˜")
}
```

**ë¬¸ì œ 7**: 1ë¶€í„° 10ê¹Œì§€ forë¬¸ìœ¼ë¡œ ì¶œë ¥í•˜ì„¸ìš”.
```go
// ë‹µì•ˆ
for i := 1; i <= 10; i++ {
    fmt.Println(i)
}
```

**ë¬¸ì œ 8**: switchë¬¸ìœ¼ë¡œ ìš”ì¼ íŒë³„í•˜ì„¸ìš”.
```go
// ë‹µì•ˆ
day := 3
switch day {
case 1:
    fmt.Println("ì›”ìš”ì¼")
case 2:
    fmt.Println("í™”ìš”ì¼")
case 3:
    fmt.Println("ìˆ˜ìš”ì¼")
default:
    fmt.Println("ê¸°íƒ€")
}
```

**ë¬¸ì œ 9**: while ëŒ€ì‹  forë¬¸ìœ¼ë¡œ ë¬´í•œë£¨í”„ ë§Œë“¤ê³  ì¡°ê±´ìœ¼ë¡œ ë¹ ì ¸ë‚˜ì˜¤ê¸°
```go
// ë‹µì•ˆ
count := 0
for {
    count++
    if count > 5 {
        break
    }
    fmt.Println(count)
}
```

**ë¬¸ì œ 10**: rangeë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ìì—´ì˜ ê° ë¬¸ì ì¶œë ¥í•˜ê¸°
```go
// ë‹µì•ˆ
text := "Hello"
for i, char := range text {
    fmt.Printf("%d: %c\n", i, char)
}
```

### 11-20: ë°°ì—´ê³¼ ìŠ¬ë¼ì´ìŠ¤
**ë¬¸ì œ 11**: ê¸¸ì´ 5ì¸ ì •ìˆ˜ ë°°ì—´ ì„ ì–¸í•˜ê³  ì´ˆê¸°í™”í•˜ì„¸ìš”.
```go
// ë‹µì•ˆ
var numbers [5]int = [5]int{1, 2, 3, 4, 5}
fmt.Println(numbers)
```

**ë¬¸ì œ 12**: ìŠ¬ë¼ì´ìŠ¤ ë§Œë“¤ê³  ìš”ì†Œ ì¶”ê°€í•˜ê¸°
```go
// ë‹µì•ˆ
fruits := []string{"apple", "banana"}
fruits = append(fruits, "orange")
fmt.Println(fruits)
```

**ë¬¸ì œ 13**: ìŠ¬ë¼ì´ìŠ¤ì—ì„œ íŠ¹ì • ë²”ìœ„ ì˜ë¼ë‚´ê¸°
```go
// ë‹µì•ˆ
nums := []int{1, 2, 3, 4, 5, 6}
slice := nums[2:5]  // [3, 4, 5]
fmt.Println(slice)
```

**ë¬¸ì œ 14**: ìŠ¬ë¼ì´ìŠ¤ ê¸¸ì´ì™€ ìš©ëŸ‰ ì¶œë ¥í•˜ê¸°
```go
// ë‹µì•ˆ
s := make([]int, 5, 10)
fmt.Printf("ê¸¸ì´: %d, ìš©ëŸ‰: %d\n", len(s), cap(s))
```

**ë¬¸ì œ 15**: 2ì°¨ì› ìŠ¬ë¼ì´ìŠ¤ ë§Œë“¤ê¸° (3x3 í–‰ë ¬)
```go
// ë‹µì•ˆ
matrix := make([][]int, 3)
for i := range matrix {
    matrix[i] = make([]int, 3)
}
fmt.Println(matrix)
```

**ë¬¸ì œ 16**: ìŠ¬ë¼ì´ìŠ¤ì—ì„œ ìµœëŒ€ê°’ ì°¾ê¸°
```go
// ë‹µì•ˆ
nums := []int{3, 7, 2, 9, 1}
max := nums[0]
for _, num := range nums {
    if num > max {
        max = num
    }
}
fmt.Println("ìµœëŒ€ê°’:", max)
```

**ë¬¸ì œ 17**: ìŠ¬ë¼ì´ìŠ¤ ì •ë ¬í•˜ê¸° (sort íŒ¨í‚¤ì§€ ì‚¬ìš©)
```go
// ë‹µì•ˆ
import "sort"
nums := []int{3, 1, 4, 1, 5}
sort.Ints(nums)
fmt.Println(nums)
```

**ë¬¸ì œ 18**: ë¬¸ìì—´ ìŠ¬ë¼ì´ìŠ¤ì—ì„œ íŠ¹ì • ë¬¸ìì—´ ì°¾ê¸°
```go
// ë‹µì•ˆ
names := []string{"Alice", "Bob", "Charlie"}
target := "Bob"
for i, name := range names {
    if name == target {
        fmt.Printf("%s found at index %d\n", target, i)
        break
    }
}
```

**ë¬¸ì œ 19**: ìŠ¬ë¼ì´ìŠ¤ ë³µì‚¬í•˜ê¸°
```go
// ë‹µì•ˆ
original := []int{1, 2, 3}
copied := make([]int, len(original))
copy(copied, original)
fmt.Println("ì›ë³¸:", original, "ë³µì‚¬:", copied)
```

**ë¬¸ì œ 20**: ìŠ¬ë¼ì´ìŠ¤ì—ì„œ ì¤‘ë³µ ì œê±°í•˜ê¸°
```go
// ë‹µì•ˆ
nums := []int{1, 2, 2, 3, 3, 3, 4}
unique := []int{}
for _, num := range nums {
    found := false
    for _, u := range unique {
        if u == num {
            found = true
            break
        }
    }
    if !found {
        unique = append(unique, num)
    }
}
fmt.Println(unique)
```

### 21-30: ë§µ(Map)
**ë¬¸ì œ 21**: ë§µ ì„ ì–¸í•˜ê³  ê°’ í• ë‹¹í•˜ê¸°
```go
// ë‹µì•ˆ
scores := make(map[string]int)
scores["Alice"] = 95
scores["Bob"] = 87
fmt.Println(scores)
```

**ë¬¸ì œ 22**: ë§µ ë¦¬í„°ëŸ´ë¡œ ì´ˆê¸°í™”í•˜ê¸°
```go
// ë‹µì•ˆ
colors := map[string]string{
    "red":   "#FF0000",
    "green": "#00FF00", 
    "blue":  "#0000FF",
}
fmt.Println(colors)
```

**ë¬¸ì œ 23**: ë§µì—ì„œ í‚¤ ì¡´ì¬ í™•ì¸í•˜ê¸°
```go
// ë‹µì•ˆ
scores := map[string]int{"Alice": 95, "Bob": 87}
if score, exists := scores["Charlie"]; exists {
    fmt.Println("Charlieì˜ ì ìˆ˜:", score)
} else {
    fmt.Println("Charlieì˜ ì ìˆ˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
}
```

**ë¬¸ì œ 24**: ë§µ ìˆœíšŒí•˜ê¸°
```go
// ë‹µì•ˆ
ages := map[string]int{"Alice": 25, "Bob": 30, "Charlie": 35}
for name, age := range ages {
    fmt.Printf("%sì€ %dì‚´ì…ë‹ˆë‹¤\n", name, age)
}
```

**ë¬¸ì œ 25**: ë§µì—ì„œ í‚¤ ì‚­ì œí•˜ê¸°
```go
// ë‹µì•ˆ
m := map[string]int{"a": 1, "b": 2, "c": 3}
delete(m, "b")
fmt.Println(m)
```

**ë¬¸ì œ 26**: ë§µì˜ ëª¨ë“  í‚¤ ì¶”ì¶œí•˜ê¸°
```go
// ë‹µì•ˆ
m := map[string]int{"apple": 5, "banana": 3, "orange": 8}
keys := []string{}
for key := range m {
    keys = append(keys, key)
}
fmt.Println("í‚¤ë“¤:", keys)
```

**ë¬¸ì œ 27**: ë§µì˜ ëª¨ë“  ê°’ í•©ê³„ êµ¬í•˜ê¸°
```go
// ë‹µì•ˆ
prices := map[string]int{"apple": 1000, "banana": 500, "orange": 800}
total := 0
for _, price := range prices {
    total += price
}
fmt.Println("ì´ ê°€ê²©:", total)
```

**ë¬¸ì œ 28**: ë‘ ë§µ í•©ì¹˜ê¸°
```go
// ë‹µì•ˆ
m1 := map[string]int{"a": 1, "b": 2}
m2 := map[string]int{"c": 3, "d": 4}
for k, v := range m2 {
    m1[k] = v
}
fmt.Println(m1)
```

**ë¬¸ì œ 29**: ë§µì—ì„œ ìµœëŒ€ê°’ì„ ê°€ì§„ í‚¤ ì°¾ê¸°
```go
// ë‹µì•ˆ
scores := map[string]int{"Alice": 95, "Bob": 87, "Charlie": 92}
maxScore := 0
maxName := ""
for name, score := range scores {
    if score > maxScore {
        maxScore = score
        maxName = name
    }
}
fmt.Printf("ìµœê³  ì ìˆ˜: %s (%dì )\n", maxName, maxScore)
```

**ë¬¸ì œ 30**: ë§µ ê°’ë“¤ë¡œ ìŠ¬ë¼ì´ìŠ¤ ë§Œë“¤ê¸°
```go
// ë‹µì•ˆ
ages := map[string]int{"Alice": 25, "Bob": 30, "Charlie": 35}
ageList := []int{}
for _, age := range ages {
    ageList = append(ageList, age)
}
fmt.Println("ë‚˜ì´ë“¤:", ageList)
```

---

## Level 2: í•¨ìˆ˜, êµ¬ì¡°ì²´, ì¸í„°í˜ì´ìŠ¤ (31-60)

### 31-40: í•¨ìˆ˜
**ë¬¸ì œ 31**: ë‘ ìˆ˜ë¥¼ ë”í•˜ëŠ” í•¨ìˆ˜ ë§Œë“¤ê¸°
```go
// ë‹µì•ˆ
func add(a, b int) int {
    return a + b
}

func main() {
    result := add(3, 5)
    fmt.Println(result)
}
```

**ë¬¸ì œ 32**: ë‹¤ì¤‘ ë°˜í™˜ê°’ì„ ê°€ì§„ í•¨ìˆ˜ (ëª«ê³¼ ë‚˜ë¨¸ì§€)
```go
// ë‹µì•ˆ
func divMod(a, b int) (int, int) {
    return a / b, a % b
}

func main() {
    quot, rem := divMod(17, 5)
    fmt.Printf("ëª«: %d, ë‚˜ë¨¸ì§€: %d\n", quot, rem)
}
```

**ë¬¸ì œ 33**: ê°€ë³€ ì¸ì í•¨ìˆ˜ë¡œ ì—¬ëŸ¬ ìˆ˜ì˜ í•© êµ¬í•˜ê¸°
```go
// ë‹µì•ˆ
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    result := sum(1, 2, 3, 4, 5)
    fmt.Println(result)
}
```

**ë¬¸ì œ 34**: í•¨ìˆ˜ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ëŠ” í•¨ìˆ˜
```go
// ë‹µì•ˆ
func apply(fn func(int) int, value int) int {
    return fn(value)
}

func square(x int) int {
    return x * x
}

func main() {
    result := apply(square, 5)
    fmt.Println(result)  // 25
}
```

**ë¬¸ì œ 35**: í´ë¡œì € í•¨ìˆ˜ ë§Œë“¤ê¸° (ì¹´ìš´í„°)
```go
// ë‹µì•ˆ
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {
    c := counter()
    fmt.Println(c())  // 1
    fmt.Println(c())  // 2
    fmt.Println(c())  // 3
}
```

**ë¬¸ì œ 36**: ì¬ê·€í•¨ìˆ˜ë¡œ íŒ©í† ë¦¬ì–¼ êµ¬í•˜ê¸°
```go
// ë‹µì•ˆ
func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n-1)
}

func main() {
    fmt.Println(factorial(5))  // 120
}
```

**ë¬¸ì œ 37**: deferë¥¼ ì‚¬ìš©í•œ í•¨ìˆ˜
```go
// ë‹µì•ˆ
func example() {
    defer fmt.Println("ë§ˆì§€ë§‰ì— ì‹¤í–‰ë¨")
    fmt.Println("ì²« ë²ˆì§¸")
    fmt.Println("ë‘ ë²ˆì§¸")
}

func main() {
    example()
}
```

**ë¬¸ì œ 38**: ì—ëŸ¬ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
```go
// ë‹µì•ˆ
import "errors"

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("ì—ëŸ¬:", err)
        return
    }
    fmt.Println("ê²°ê³¼:", result)
}
```

**ë¬¸ì œ 39**: ëª…ëª…ëœ ë°˜í™˜ê°’ ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func calculate(a, b int) (sum, product int) {
    sum = a + b
    product = a * b
    return  // ëª…ì‹œì ìœ¼ë¡œ sum, product ë°˜í™˜
}

func main() {
    s, p := calculate(3, 4)
    fmt.Printf("í•©: %d, ê³±: %d\n", s, p)
}
```

**ë¬¸ì œ 40**: í•¨ìˆ˜ íƒ€ì…ì„ ë³€ìˆ˜ë¡œ ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
type operation func(int, int) int

func add(a, b int) int { return a + b }
func multiply(a, b int) int { return a * b }

func main() {
    var op operation
    op = add
    fmt.Println(op(3, 4))  // 7
    
    op = multiply
    fmt.Println(op(3, 4))  // 12
}
```

### 41-50: êµ¬ì¡°ì²´
**ë¬¸ì œ 41**: ê¸°ë³¸ êµ¬ì¡°ì²´ ì •ì˜í•˜ê³  ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Alice", Age: 25}
    fmt.Printf("%+v\n", p)
}
```

**ë¬¸ì œ 42**: êµ¬ì¡°ì²´ í¬ì¸í„° ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
type Point struct {
    X, Y int
}

func main() {
    p := &Point{X: 1, Y: 2}
    fmt.Printf("X: %d, Y: %d\n", p.X, p.Y)
}
```

**ë¬¸ì œ 43**: êµ¬ì¡°ì²´ì— ë©”ì„œë“œ ì¶”ê°€í•˜ê¸°
```go
// ë‹µì•ˆ
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func main() {
    rect := Rectangle{Width: 5, Height: 3}
    fmt.Println("ë„“ì´:", rect.Area())
}
```

**ë¬¸ì œ 44**: í¬ì¸í„° ë¦¬ì‹œë²„ ë©”ì„œë“œ
```go
// ë‹µì•ˆ
type Counter struct {
    Value int
}

func (c *Counter) Increment() {
    c.Value++
}

func main() {
    counter := Counter{Value: 0}
    counter.Increment()
    fmt.Println(counter.Value)  // 1
}
```

**ë¬¸ì œ 45**: êµ¬ì¡°ì²´ ì„ë² ë”© (ìƒì†)
```go
// ë‹µì•ˆ
type Animal struct {
    Name string
}

func (a Animal) Speak() string {
    return "ë™ë¬¼ì´ ì†Œë¦¬ë¥¼ ëƒ…ë‹ˆë‹¤"
}

type Dog struct {
    Animal
    Breed string
}

func main() {
    dog := Dog{
        Animal: Animal{Name: "ë©ë©ì´"},
        Breed:  "ê³¨ë“  ë¦¬íŠ¸ë¦¬ë²„",
    }
    fmt.Println(dog.Name)    // Animalì˜ í•„ë“œ
    fmt.Println(dog.Speak()) // Animalì˜ ë©”ì„œë“œ
}
```

**ë¬¸ì œ 46**: êµ¬ì¡°ì²´ ìŠ¬ë¼ì´ìŠ¤ ì •ë ¬í•˜ê¸°
```go
// ë‹µì•ˆ
import "sort"

type Student struct {
    Name  string
    Score int
}

type ByScore []Student

func (s ByScore) Len() int           { return len(s) }
func (s ByScore) Less(i, j int) bool { return s[i].Score > s[j].Score }
func (s ByScore) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

func main() {
    students := []Student{
        {"Alice", 85},
        {"Bob", 95},
        {"Charlie", 78},
    }
    sort.Sort(ByScore(students))
    fmt.Println(students)
}
```

**ë¬¸ì œ 47**: JSON ë§ˆìƒ¬ë§/ì–¸ë§ˆìƒ¬ë§
```go
// ë‹µì•ˆ
import (
    "encoding/json"
    "fmt"
)

type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

func main() {
    user := User{Name: "Alice", Email: "alice@example.com", Age: 25}
    
    // JSONìœ¼ë¡œ ë³€í™˜
    jsonData, _ := json.Marshal(user)
    fmt.Println(string(jsonData))
    
    // JSONì—ì„œ êµ¬ì¡°ì²´ë¡œ ë³€í™˜
    var newUser User
    json.Unmarshal(jsonData, &newUser)
    fmt.Printf("%+v\n", newUser)
}
```

**ë¬¸ì œ 48**: êµ¬ì¡°ì²´ ìƒì„±ì íŒ¨í„´
```go
// ë‹µì•ˆ
type BankAccount struct {
    owner   string
    balance float64
}

func NewBankAccount(owner string, initialBalance float64) *BankAccount {
    return &BankAccount{
        owner:   owner,
        balance: initialBalance,
    }
}

func (ba *BankAccount) GetBalance() float64 {
    return ba.balance
}

func main() {
    account := NewBankAccount("Alice", 1000.0)
    fmt.Println("ì”ê³ :", account.GetBalance())
}
```

**ë¬¸ì œ 49**: ìµëª… êµ¬ì¡°ì²´ ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func main() {
    person := struct {
        Name string
        Age  int
    }{
        Name: "Bob",
        Age:  30,
    }
    fmt.Printf("%+v\n", person)
}
```

**ë¬¸ì œ 50**: êµ¬ì¡°ì²´ ë¹„êµí•˜ê¸°
```go
// ë‹µì•ˆ
type Point struct {
    X, Y int
}

func main() {
    p1 := Point{X: 1, Y: 2}
    p2 := Point{X: 1, Y: 2}
    p3 := Point{X: 2, Y: 3}
    
    fmt.Println("p1 == p2:", p1 == p2)  // true
    fmt.Println("p1 == p3:", p1 == p3)  // false
}
```

### 51-60: ì¸í„°í˜ì´ìŠ¤
**ë¬¸ì œ 51**: ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤ ì •ì˜í•˜ê³  êµ¬í˜„í•˜ê¸°
```go
// ë‹µì•ˆ
type Shape interface {
    Area() float64
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

func main() {
    var s Shape = Circle{Radius: 5}
    fmt.Println("ë„“ì´:", s.Area())
}
```

**ë¬¸ì œ 52**: ì—¬ëŸ¬ íƒ€ì…ì´ ê°™ì€ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„í•˜ê¸°
```go
// ë‹µì•ˆ
type Speaker interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string { return "ë©ë©!" }

type Cat struct{}
func (c Cat) Speak() string { return "ì•¼ì˜¹!" }

func makeNoise(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    makeNoise(Dog{})  // ë©ë©!
    makeNoise(Cat{})  // ì•¼ì˜¹!
}
```

**ë¬¸ì œ 53**: ë¹ˆ ì¸í„°í˜ì´ìŠ¤ (interface{}) ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func printAnything(value interface{}) {
    fmt.Printf("ê°’: %v, íƒ€ì…: %T\n", value, value)
}

func main() {
    printAnything(42)
    printAnything("hello")
    printAnything([]int{1, 2, 3})
}
```

**ë¬¸ì œ 54**: íƒ€ì… ë‹¨ì–¸ (Type Assertion) ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func checkType(value interface{}) {
    if str, ok := value.(string); ok {
        fmt.Printf("ë¬¸ìì—´: %s (ê¸¸ì´: %d)\n", str, len(str))
    } else {
        fmt.Printf("ë¬¸ìì—´ì´ ì•„ë‹˜: %T\n", value)
    }
}

func main() {
    checkType("hello")
    checkType(42)
}
```

**ë¬¸ì œ 55**: íƒ€ì… ìŠ¤ìœ„ì¹˜ ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func describeType(value interface{}) {
    switch v := value.(type) {
    case string:
        fmt.Printf("ë¬¸ìì—´: %s\n", v)
    case int:
        fmt.Printf("ì •ìˆ˜: %d\n", v)
    case bool:
        fmt.Printf("ë¶ˆë¦°: %t\n", v)
    default:
        fmt.Printf("ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ì…: %T\n", v)
    }
}

func main() {
    describeType("hello")
    describeType(42)
    describeType(true)
    describeType(3.14)
}
```

**ë¬¸ì œ 56**: ì¸í„°í˜ì´ìŠ¤ í•©ì„±
```go
// ë‹µì•ˆ
type Reader interface {
    Read() string
}

type Writer interface {
    Write(string)
}

type ReadWriter interface {
    Reader
    Writer
}

type File struct {
    content string
}

func (f *File) Read() string {
    return f.content
}

func (f *File) Write(data string) {
    f.content = data
}

func main() {
    var rw ReadWriter = &File{}
    rw.Write("Hello, World!")
    fmt.Println(rw.Read())
}
```

**ë¬¸ì œ 57**: ì¸í„°í˜ì´ìŠ¤ ê°’ nil ì²´í¬
```go
// ë‹µì•ˆ
type Printer interface {
    Print()
}

type ConsolePrinter struct{}
func (cp ConsolePrinter) Print() { fmt.Println("ì½˜ì†” ì¶œë ¥") }

func main() {
    var p Printer
    if p == nil {
        fmt.Println("Printerê°€ nilì…ë‹ˆë‹¤")
    }
    
    p = ConsolePrinter{}
    if p != nil {
        p.Print()
    }
}
```

**ë¬¸ì œ 58**: ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ëŠ” í•¨ìˆ˜
```go
// ë‹µì•ˆ
type Comparable interface {
    Compare(other Comparable) int
}

type Number struct {
    Value int
}

func (n Number) Compare(other Comparable) int {
    if otherNum, ok := other.(Number); ok {
        if n.Value < otherNum.Value {
            return -1
        } else if n.Value > otherNum.Value {
            return 1
        }
        return 0
    }
    return 0
}

func findMax(items []Comparable) Comparable {
    if len(items) == 0 {
        return nil
    }
    max := items[0]
    for _, item := range items[1:] {
        if item.Compare(max) > 0 {
            max = item
        }
    }
    return max
}

func main() {
    numbers := []Comparable{Number{5}, Number{2}, Number{8}, Number{1}}
    max := findMax(numbers)
    fmt.Printf("ìµœëŒ€ê°’: %+v\n", max)
}
```

**ë¬¸ì œ 59**: ì¸í„°í˜ì´ìŠ¤ ìŠ¬ë¼ì´ìŠ¤ ë‹¤ë£¨ê¸°
```go
// ë‹µì•ˆ
type Animal interface {
    MakeSound() string
}

type Dog struct{ Name string }
func (d Dog) MakeSound() string { return "ë©ë©" }

type Cat struct{ Name string }
func (c Cat) MakeSound() string { return "ì•¼ì˜¹" }

func main() {
    animals := []Animal{
        Dog{Name: "ë©ë©ì´"},
        Cat{Name: "ì•¼ì˜¹ì´"},
        Dog{Name: "ì™ˆì™ˆì´"},
    }
    
    for _, animal := range animals {
        fmt.Println(animal.MakeSound())
    }
}
```

**ë¬¸ì œ 60**: ë©”ì„œë“œ ì…‹ê³¼ ì¸í„°í˜ì´ìŠ¤
```go
// ë‹µì•ˆ
type Incrementer interface {
    Increment()
    GetValue() int
}

type Counter struct {
    value int
}

func (c *Counter) Increment() {
    c.value++
}

func (c *Counter) GetValue() int {
    return c.value
}

func useIncrementer(inc Incrementer) {
    inc.Increment()
    fmt.Println("í˜„ì¬ ê°’:", inc.GetValue())
}

func main() {
    counter := &Counter{value: 0}
    useIncrementer(counter)
}
```

---

## Level 3: ê³ ë£¨í‹´ê³¼ ì±„ë„ (61-85)

### 61-70: ê³ ë£¨í‹´ ê¸°ì´ˆ
**ë¬¸ì œ 61**: ê¸°ë³¸ ê³ ë£¨í‹´ ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
import "time"

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    go sayHello()
    time.Sleep(time.Second)  // ê³ ë£¨í‹´ì´ ì‹¤í–‰ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
    fmt.Println("Main function ending")
}
```

**ë¬¸ì œ 62**: ì—¬ëŸ¬ ê³ ë£¨í‹´ ë™ì‹œ ì‹¤í–‰
```go
// ë‹µì•ˆ
func worker(id int) {
    fmt.Printf("Worker %d started\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d finished\n", id)
}

func main() {
    for i := 1; i <= 3; i++ {
        go worker(i)
    }
    time.Sleep(2 * time.Second)
}
```

**ë¬¸ì œ 63**: sync.WaitGroup ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
import "sync"

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Worker %d working...\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    
    wg.Wait()
    fmt.Println("All workers finished")
}
```

**ë¬¸ì œ 64**: ê²½ìŸ ìƒíƒœ(Race Condition) ì˜ˆì œ
```go
// ë‹µì•ˆ
var counter int

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i < 1000; i++ {
        counter++  // ê²½ìŸ ìƒíƒœ ë°œìƒ!
    }
}

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 2; i++ {
        wg.Add(1)
        go increment(&wg)
    }
    
    wg.Wait()
    fmt.Printf("Counter: %d\n", counter)  // ì˜ˆìƒ: 2000, ì‹¤ì œ: ?
}
```

**ë¬¸ì œ 65**: Mutexë¡œ ê²½ìŸ ìƒíƒœ í•´ê²°í•˜ê¸°
```go
// ë‹µì•ˆ
var (
    counter int
    mutex   sync.Mutex
)

func safeIncrement(wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i < 1000; i++ {
        mutex.Lock()
        counter++
        mutex.Unlock()
    }
}

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 2; i++ {
        wg.Add(1)
        go safeIncrement(&wg)
    }
    
    wg.Wait()
    fmt.Printf("Safe Counter: %d\n", counter)  // ì •í™•íˆ 2000
}
```

**ë¬¸ì œ 66**: ê³ ë£¨í‹´ì—ì„œ íŒ¨ë‹‰ ì²˜ë¦¬í•˜ê¸°
```go
// ë‹µì•ˆ
func riskyOperation(id int) {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Goroutine %d recovered from: %v\n", id, r)
        }
    }()
    
    if id == 2 {
        panic("Something went wrong!")
    }
    
    fmt.Printf("Goroutine %d completed successfully\n", id)
}

func main() {
    for i := 1; i <= 3; i++ {
        go riskyOperation(i)
    }
    time.Sleep(time.Second)
}
```

**ë¬¸ì œ 67**: ê³ ë£¨í‹´ í’€ íŒ¨í„´
```go
// ë‹µì•ˆ
func workerPool(jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    for job := range jobs {
        results <- job * 2  // ì‘ì—… ì²˜ë¦¬ (2ë°°)
    }
}

func main() {
    const numWorkers = 3
    const numJobs = 9
    
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    
    var wg sync.WaitGroup
    
    // ì›Œì»¤ ì‹œì‘
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go workerPool(jobs, results, &wg)
    }
    
    // ì‘ì—… ì „ì†¡
    for i := 1; i <= numJobs; i++ {
        jobs <- i
    }
    close(jobs)
    
    // ì›Œì»¤ ì¢…ë£Œ ëŒ€ê¸°
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // ê²°ê³¼ ìˆ˜ì§‘
    for result := range results {
        fmt.Printf("Result: %d\n", result)
    }
}
```

**ë¬¸ì œ 68**: ê³ ë£¨í‹´ ë¦¬í¬ ë°©ì§€
```go
// ë‹µì•ˆ
func leakyGoroutine() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "data"  // ë°›ì„ ê³ ë£¨í‹´ì´ ì—†ìœ¼ë©´ ì˜ì›íˆ ë¸”ë¡ë¨
    }()
    
    // 1ì´ˆ í›„ íƒ€ì„ì•„ì›ƒ
    select {
    case data := <-ch:
        fmt.Println("Received:", data)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout!")
        return  // ì—¬ê¸°ì„œ ë°˜í™˜í•˜ë©´ ch <- "data"ê°€ ì˜ì›íˆ ë¸”ë¡ë¨
    }
}

func fixedGoroutine() {
    ch := make(chan string, 1)  // ë²„í¼ë“œ ì±„ë„ ì‚¬ìš©
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "data"  // ë²„í¼ê°€ ìˆì–´ì„œ ë¸”ë¡ë˜ì§€ ì•ŠìŒ
    }()
    
    select {
    case data := <-ch:
        fmt.Println("Received:", data)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout!")
    }
}
```

**ë¬¸ì œ 69**: ì»¨í…ìŠ¤íŠ¸ë¡œ ê³ ë£¨í‹´ ì·¨ì†Œí•˜ê¸°
```go
// ë‹µì•ˆ
import "context"

func cancellableWorker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d cancelled\n", id)
            return
        default:
            fmt.Printf("Worker %d working...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    
    for i := 1; i <= 3; i++ {
        go cancellableWorker(ctx, i)
    }
    
    time.Sleep(2 * time.Second)
    cancel()  // ëª¨ë“  ì›Œì»¤ ì·¨ì†Œ
    time.Sleep(time.Second)
}
```

**ë¬¸ì œ 70**: ê³ ë£¨í‹´ìœ¼ë¡œ íŒ¬ì•„ì›ƒ/íŒ¬ì¸ íŒ¨í„´
```go
// ë‹µì•ˆ
func producer(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

func main() {
    // íŒ¬ì•„ì›ƒ
    c := producer(2, 3, 4)
    
    // íŒ¬ì¸
    c1 := square(c)
    c2 := square(c)
    
    // ê²°ê³¼ ìˆ˜ì§‘
    for n := range c1 {
        fmt.Println(n)
    }
    for n := range c2 {
        fmt.Println(n)
    }
}
```

### 71-80: ì±„ë„ í™œìš©
**ë¬¸ì œ 71**: ê¸°ë³¸ ì±„ë„ ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func main() {
    ch := make(chan string)
    
    go func() {
        ch <- "Hello, Channel!"
    }()
    
    message := <-ch
    fmt.Println(message)
}
```

**ë¬¸ì œ 72**: ë²„í¼ë“œ ì±„ë„ ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func main() {
    ch := make(chan int, 2)
    
    ch <- 1
    ch <- 2
    // ch <- 3  // ì´ê±´ ë¸”ë¡ë¨ (ë²„í¼ í¬ê¸° 2)
    
    fmt.Println(<-ch)  // 1
    fmt.Println(<-ch)  // 2
}
```

**ë¬¸ì œ 73**: ì±„ë„ ë‹«ê¸°ì™€ ë²”ìœ„ ë£¨í”„
```go
// ë‹µì•ˆ
func fibonacci(n int, c chan int) {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        c <- x
        x, y = y, x+y
    }
    close(c)
}

func main() {
    c := make(chan int, 10)
    go fibonacci(cap(c), c)
    
    for num := range c {
        fmt.Println(num)
    }
}
```

**ë¬¸ì œ 74**: select ë¬¸ìœ¼ë¡œ ë‹¤ì¤‘ ì±„ë„ ì²˜ë¦¬
```go
// ë‹µì•ˆ
func main() {
    c1 := make(chan string)
    c2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("Received", msg1)
        case msg2 := <-c2:
            fmt.Println("Received", msg2)
        }
    }
}
```

**ë¬¸ì œ 75**: selectì™€ defaultë¡œ ë…¼ë¸”ë¡œí‚¹ ì²˜ë¦¬
```go
// ë‹µì•ˆ
func main() {
    ch := make(chan string)
    
    select {
    case msg := <-ch:
        fmt.Println("Received:", msg)
    default:
        fmt.Println("No message received")
    }
}
```

**ë¬¸ì œ 76**: íƒ€ì´ë¨¸ì™€ ì±„ë„
```go
// ë‹µì•ˆ
func main() {
    timer1 := time.NewTimer(2 * time.Second)
    
    <-timer1.C
    fmt.Println("Timer 1 expired")
    
    timer2 := time.NewTimer(time.Second)
    go func() {
        <-timer2.C
        fmt.Println("Timer 2 expired")
    }()
    
    stop2 := timer2.Stop()
    if stop2 {
        fmt.Println("Timer 2 stopped")
    }
    
    time.Sleep(2 * time.Second)
}
```

**ë¬¸ì œ 77**: í‹°ì»¤(Ticker) ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func main() {
    ticker := time.NewTicker(500 * time.Millisecond)
    done := make(chan bool)
    
    go func() {
        for {
            select {
            case <-done:
                return
            case t := <-ticker.C:
                fmt.Println("Tick at", t)
            }
        }
    }()
    
    time.Sleep(1600 * time.Millisecond)
    ticker.Stop()
    done <- true
    fmt.Println("Ticker stopped")
}
```

**ë¬¸ì œ 78**: íŒŒì´í”„ë¼ì¸ íŒ¨í„´
```go
// ë‹µì•ˆ
func pipeline() {
    // Stage 1: ìˆ«ì ìƒì„±
    numbers := make(chan int)
    go func() {
        for i := 1; i <= 5; i++ {
            numbers <- i
        }
        close(numbers)
    }()
    
    // Stage 2: ì œê³± ê³„ì‚°
    squares := make(chan int)
    go func() {
        for n := range numbers {
            squares <- n * n
        }
        close(squares)
    }()
    
    // Stage 3: ê²°ê³¼ ì¶œë ¥
    for s := range squares {
        fmt.Println("Square:", s)
    }
}

func main() {
    pipeline()
}
```

**ë¬¸ì œ 79**: ì±„ë„ë¡œ ì„¸ë§ˆí¬ì–´ êµ¬í˜„í•˜ê¸°
```go
// ë‹µì•ˆ
type Semaphore chan struct{}

func NewSemaphore(maxConcurrency int) Semaphore {
    return make(chan struct{}, maxConcurrency)
}

func (s Semaphore) Acquire() {
    s <- struct{}{}
}

func (s Semaphore) Release() {
    <-s
}

func worker(id int, sem Semaphore, wg *sync.WaitGroup) {
    defer wg.Done()
    
    sem.Acquire()
    defer sem.Release()
    
    fmt.Printf("Worker %d working...\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    sem := NewSemaphore(2)  // ìµœëŒ€ 2ê°œ ë™ì‹œ ì‹¤í–‰
    var wg sync.WaitGroup
    
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, sem, &wg)
    }
    
    wg.Wait()
}
```

**ë¬¸ì œ 80**: ì±„ë„ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸ êµ¬í˜„í•˜ê¸°
```go
// ë‹µì•ˆ
type Broadcaster struct {
    listeners []chan string
    mutex     sync.Mutex
}

func NewBroadcaster() *Broadcaster {
    return &Broadcaster{
        listeners: make([]chan string, 0),
    }
}

func (b *Broadcaster) Subscribe() <-chan string {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    ch := make(chan string, 10)
    b.listeners = append(b.listeners, ch)
    return ch
}

func (b *Broadcaster) Broadcast(message string) {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    for _, listener := range b.listeners {
        select {
        case listener <- message:
        default:  // ë²„í¼ê°€ ê°€ë“ ì°¨ë©´ ìŠ¤í‚µ
        }
    }
}

func main() {
    broadcaster := NewBroadcaster()
    
    // êµ¬ë…ìë“¤
    sub1 := broadcaster.Subscribe()
    sub2 := broadcaster.Subscribe()
    
    go func() {
        for msg := range sub1 {
            fmt.Println("Sub1 received:", msg)
        }
    }()
    
    go func() {
        for msg := range sub2 {
            fmt.Println("Sub2 received:", msg)
        }
    }()
    
    broadcaster.Broadcast("Hello")
    broadcaster.Broadcast("World")
    
    time.Sleep(time.Second)
}
```

### 81-85: ë™ì‹œì„± íŒ¨í„´
**ë¬¸ì œ 81**: Onceë¥¼ ì‚¬ìš©í•œ ì´ˆê¸°í™”
```go
// ë‹µì•ˆ
var once sync.Once
var instance *Singleton

type Singleton struct {
    value string
}

func GetSingleton() *Singleton {
    once.Do(func() {
        fmt.Println("Creating singleton instance")
        instance = &Singleton{value: "I'm a singleton"}
    })
    return instance
}

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            s := GetSingleton()
            fmt.Printf("Goroutine %d got: %s\n", id, s.value)
        }(i)
    }
    
    wg.Wait()
}
```

**ë¬¸ì œ 82**: RWMutex ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
type SafeCounter struct {
    mutex sync.RWMutex
    count map[string]int
}

func (c *SafeCounter) Get(key string) int {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    return c.count[key]
}

func (c *SafeCounter) Set(key string, value int) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    if c.count == nil {
        c.count = make(map[string]int)
    }
    c.count[key] = value
}

func main() {
    counter := &SafeCounter{}
    
    var wg sync.WaitGroup
    
    // ì—¬ëŸ¬ ê³ ë£¨í‹´ì—ì„œ ë™ì‹œ ì½ê¸°/ì“°ê¸°
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id)
            counter.Set(key, id*10)
            fmt.Printf("Set %s = %d\n", key, id*10)
        }(i)
    }
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id%3)
            value := counter.Get(key)
            fmt.Printf("Get %s = %d\n", key, value)
        }(i)
    }
    
    wg.Wait()
}
```

**ë¬¸ì œ 83**: ì¡°ê±´ ë³€ìˆ˜(Cond) ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
func main() {
    var mutex sync.Mutex
    cond := sync.NewCond(&mutex)
    ready := false
    
    // ê¸°ë‹¤ë¦¬ëŠ” ê³ ë£¨í‹´ë“¤
    for i := 1; i <= 3; i++ {
        go func(id int) {
            mutex.Lock()
            for !ready {
                fmt.Printf("Worker %d waiting...\n", id)
                cond.Wait()
            }
            fmt.Printf("Worker %d starting work!\n", id)
            mutex.Unlock()
        }(i)
    }
    
    time.Sleep(2 * time.Second)
    
    // ì‹ í˜¸ ë³´ë‚´ê¸°
    mutex.Lock()
    ready = true
    mutex.Unlock()
    cond.Broadcast()  // ëª¨ë“  ëŒ€ê¸° ì¤‘ì¸ ê³ ë£¨í‹´ì—ê²Œ ì‹ í˜¸
    
    time.Sleep(time.Second)
}
```

**ë¬¸ì œ 84**: ì›ìì  ì—°ì‚° ì‚¬ìš©í•˜ê¸°
```go
// ë‹µì•ˆ
import "sync/atomic"

var counter int64

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i < 1000; i++ {
        atomic.AddInt64(&counter, 1)
    }
}

func main() {
    var wg sync.WaitGroup
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go increment(&wg)
    }
    
    wg.Wait()
    fmt.Printf("Atomic counter: %d\n", atomic.LoadInt64(&counter))
}
```

**ë¬¸ì œ 85**: ê³ ë£¨í‹´ í’€ì„ ì´ìš©í•œ ì‘ì—… ìŠ¤ì¼€ì¤„ëŸ¬
```go
// ë‹µì•ˆ
type Job func()

type WorkerPool struct {
    jobQueue    chan Job
    workerQueue chan chan Job
    workers     []*Worker
    quit        chan bool
}

type Worker struct {
    id          int
    jobChannel  chan Job
    workerQueue chan chan Job
    quit        chan bool
}

func NewWorker(id int, workerQueue chan chan Job) *Worker {
    return &Worker{
        id:          id,
        jobChannel:  make(chan Job),
        workerQueue: workerQueue,
        quit:        make(chan bool),
    }
}

func (w *Worker) Start() {
    go func() {
        for {
            w.workerQueue <- w.jobChannel
            
            select {
            case job := <-w.jobChannel:
                job()
            case <-w.quit:
                return
            }
        }
    }()
}

func NewWorkerPool(maxWorkers int, maxQueue int) *WorkerPool {
    pool := &WorkerPool{
        jobQueue:    make(chan Job, maxQueue),
        workerQueue: make(chan chan Job, maxWorkers),
        workers:     make([]*Worker, maxWorkers),
        quit:        make(chan bool),
    }
    
    for i := 0; i < maxWorkers; i++ {
        worker := NewWorker(i+1, pool.workerQueue)
        pool.workers[i] = worker
        worker.Start()
    }
    
    go pool.dispatch()
    return pool
}

func (p *WorkerPool) dispatch() {
    for {
        select {
        case job := <-p.jobQueue:
            go func() {
                workerJobChannel := <-p.workerQueue
                workerJobChannel <- job
            }()
        case <-p.quit:
            return
        }
    }
}

func (p *WorkerPool) Submit(job Job) {
    p.jobQueue <- job
}

func main() {
    pool := NewWorkerPool(3, 10)
    
    for i := 1; i <= 10; i++ {
        jobID := i
        pool.Submit(func() {
            fmt.Printf("Job %d started\n", jobID)
            time.Sleep(time.Second)
            fmt.Printf("Job %d completed\n", jobID)
        })
    }
    
    time.Sleep(5 * time.Second)
}
```

---

## Level 4: ë„¤íŠ¸ì›Œí¬ì™€ ì‹¤ì „ ì‘ìš© (86-100)

### 86-95: ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°
**ë¬¸ì œ 86**: TCP ì„œë²„ ë§Œë“¤ê¸°
```go
// ë‹µì•ˆ
import "net"

func handleConnection(conn net.Conn) {
    defer conn.Close()
    
    buffer := make([]byte, 1024)
    for {
        n, err := conn.Read(buffer)
        if err != nil {
            fmt.Println("Connection closed")
            return
        }
        
        message := string(buffer[:n])
        fmt.Printf("Received: %s", message)
        
        // ì—ì½”
        conn.Write(buffer[:n])
    }
}

func main() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        panic(err)
    }
    defer listener.Close()
    
    fmt.Println("Server listening on :8080")
    
    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("Error accepting connection:", err)
            continue
        }
        
        go handleConnection(conn)
    }
}
```

**ë¬¸ì œ 87**: TCP í´ë¼ì´ì–¸íŠ¸ ë§Œë“¤ê¸°
```go
// ë‹µì•ˆ
func main() {
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        panic(err)
    }
    defer conn.Close()
    
    // ë©”ì‹œì§€ ì „ì†¡
    message := "Hello, Server!"
    _, err = conn.Write([]byte(message))
    if err != nil {
        panic(err)
    }
    
    // ì‘ë‹µ ë°›ê¸°
    buffer := make([]byte, 1024)
    n, err := conn.Read(buffer)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Server response: %s\n", string(buffer[:n]))
}
```

**ë¬¸ì œ 88**: HTTP ì„œë²„ ë§Œë“¤ê¸°
```go
// ë‹µì•ˆ
import "net/http"

func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!", r.URL.Path[1:])
}

func jsonHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    response := map[string]interface{}{
        "message": "Hello, JSON!",
        "status":  "success",
        "data":    []int{1, 2, 3, 4, 5},
    }
    
    json.NewEncoder(w).Encode(response)
}

func main() {
    http.HandleFunc("/hello/", helloHandler)
    http.HandleFunc("/json", jsonHandler)
    
    fmt.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**ë¬¸ì œ 89**: HTTP í´ë¼ì´ì–¸íŠ¸ë¡œ API í˜¸ì¶œí•˜ê¸°
```go
// ë‹µì•ˆ
func main() {
    // GET ìš”ì²­
    resp, err := http.Get("https://jsonplaceholder.typicode.com/posts/1")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Response: %s\n", string(body))
    
    // POST ìš”ì²­
    postData := map[string]interface{}{
        "title":  "My Post",
        "body":   "This is the body",
        "userId": 1,
    }
    
    jsonData, _ := json.Marshal(postData)
    
    postResp, err := http.Post(
        "https://jsonplaceholder.typicode.com/posts",
        "application/json",
        bytes.NewBuffer(jsonData),
    )
    if err != nil {
        panic(err)
    }
    defer postResp.Body.Close()
    
    postBody, _ := ioutil.ReadAll(postResp.Body)
    fmt.Printf("POST Response: %s\n", string(postBody))
}
```

**ë¬¸ì œ 90**: RPC ì„œë²„ ë§Œë“¤ê¸°
```go
// ë‹µì•ˆ
import (
    "net"
    "net/http"
    "net/rpc"
)

type Calculator struct{}

type Args struct {
    A, B int
}

func (c *Calculator) Add(args *Args, result *int) error {
    *result = args.A + args.B
    return nil
}

func (c *Calculator) Multiply(args *Args, result *int) error {
    *result = args.A * args.B
    return nil
}

func main() {
    calculator := &Calculator{}
    rpc.Register(calculator)
    rpc.HandleHTTP()
    
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        panic(err)
    }
    
    fmt.Println("RPC server starting on :8080")
    http.Serve(listener, nil)
}
```

**ë¬¸ì œ 91**: RPC í´ë¼ì´ì–¸íŠ¸ ë§Œë“¤ê¸°
```go
// ë‹µì•ˆ
func main() {
    client, err := rpc.DialHTTP("tcp", "localhost:8080")
    if err != nil {
        panic(err)
    }
    defer client.Close()
    
    // Add í˜¸ì¶œ
    args := &Args{A: 5, B: 3}
    var addResult int
    err = client.Call("Calculator.Add", args, &addResult)
    if err != nil {
        panic(err)
    }
    fmt.Printf("5 + 3 = %d\n", addResult)
    
    // Multiply í˜¸ì¶œ
    var mulResult int
    err = client.Call("Calculator.Multiply", args, &mulResult)
    if err != nil {
        panic(err)
    }
    fmt.Printf("5 * 3 = %d\n", mulResult)
}
```

**ë¬¸ì œ 92**: WebSocket ì„œë²„ (gorilla/websocket ì‚¬ìš©)
```go
// ë‹µì•ˆ
// go get github.com/gorilla/websocket
import "github.com/gorilla/websocket"

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true  // ëª¨ë“  ì˜¤ë¦¬ì§„ í—ˆìš© (í”„ë¡œë•ì…˜ì—ì„œëŠ” ì œí•œ í•„ìš”)
    },
}

func wsHandler(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        fmt.Println("Upgrade error:", err)
        return
    }
    defer conn.Close()
    
    for {
        messageType, message, err := conn.ReadMessage()
        if err != nil {
            fmt.Println("Read error:", err)
            break
        }
        
        fmt.Printf("Received: %s\n", message)
        
        // ì—ì½”
        err = conn.WriteMessage(messageType, message)
        if err != nil {
            fmt.Println("Write error:", err)
            break
        }
    }
}

func main() {
    http.HandleFunc("/ws", wsHandler)
    fmt.Println("WebSocket server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**ë¬¸ì œ 93**: íŒŒì¼ ì—…ë¡œë“œ HTTP ì„œë²„
```go
// ë‹µì•ˆ
func uploadHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "POST" {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    err := r.ParseMultipartForm(10 << 20)  // 10 MB ì œí•œ
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    file, handler, err := r.FormFile("uploadfile")
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    defer file.Close()
    
    fmt.Printf("Uploaded File: %s\n", handler.Filename)
    fmt.Printf("File Size: %d\n", handler.Size)
    
    // íŒŒì¼ ì €ì¥
    f, err := os.OpenFile("./uploads/"+handler.Filename, 
        os.O_WRONLY|os.O_CREATE, 0666)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    defer f.Close()
    
    io.Copy(f, file)
    
    fmt.Fprintf(w, "File uploaded successfully: %s", handler.Filename)
}

func main() {
    os.MkdirAll("./uploads", os.ModePerm)
    
    http.HandleFunc("/upload", uploadHandler)
    fmt.Println("File upload server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**ë¬¸ì œ 94**: ë¯¸ë“¤ì›¨ì–´ íŒ¨í„´ìœ¼ë¡œ HTTP ì„œë²„
```go
// ë‹µì•ˆ
type Middleware func(http.HandlerFunc) http.HandlerFunc

func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next(w, r)
        fmt.Printf("%s %s %v\n", r.Method, r.URL.Path, time.Since(start))
    }
}

func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if token != "Bearer secret-token" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next(w, r)
    }
}

func chainMiddleware(h http.HandlerFunc, middlewares ...Middleware) http.HandlerFunc {
    for i := len(middlewares) - 1; i >= 0; i-- {
        h = middlewares[i](h)
    }
    return h
}

func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, authenticated user!")
}

func publicHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "This is a public endpoint")
}

func main() {
    protectedHandler := chainMiddleware(helloHandler, 
        loggingMiddleware, authMiddleware)
    
    publicHandlerWithLogging := chainMiddleware(publicHandler, 
        loggingMiddleware)
    
    http.HandleFunc("/protected", protectedHandler)
    http.HandleFunc("/public", publicHandlerWithLogging)
    
    fmt.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**ë¬¸ì œ 95**: ë¡œë“œ ë°¸ëŸ°ì„œ êµ¬í˜„í•˜ê¸°
```go
// ë‹µì•ˆ
import "sync/atomic"

type Backend struct {
    URL   string
    Alive bool
}

type LoadBalancer struct {
    backends []*Backend
    current  uint64
}

func (lb *LoadBalancer) GetNextBackend() *Backend {
    if len(lb.backends) == 0 {
        return nil
    }
    
    // ë¼ìš´ë“œ ë¡œë¹ˆ
    next := atomic.AddUint64(&lb.current, 1)
    return lb.backends[next%uint64(len(lb.backends))]
}

func (lb *LoadBalancer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    backend := lb.GetNextBackend()
    if backend == nil {
        http.Error(w, "No backend available", http.StatusServiceUnavailable)
        return
    }
    
    // í”„ë¡ì‹œ ìš”ì²­
    backendURL := backend.URL + r.URL.Path
    resp, err := http.Get(backendURL)
    if err != nil {
        http.Error(w, "Backend error", http.StatusBadGateway)
        return
    }
    defer resp.Body.Close()
    
    // ì‘ë‹µ ë³µì‚¬
    for k, v := range resp.Header {
        w.Header()[k] = v
    }
    w.WriteHeader(resp.StatusCode)
    io.Copy(w, resp.Body)
}

func main() {
    backends := []*Backend{
        {URL: "http://localhost:8081", Alive: true},
        {URL: "http://localhost:8082", Alive: true},
        {URL: "http://localhost:8083", Alive: true},
    }
    
    lb := &LoadBalancer{backends: backends}
    
    fmt.Println("Load balancer starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", lb))
}
```

### 96-100: ì¢…í•© ì‹¤ì „ ë¬¸ì œ
**ë¬¸ì œ 96**: ì±„íŒ… ì„œë²„ (WebSocket + ì±„ë„)
```go
// ë‹µì•ˆ
type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub  *Hub
    conn *websocket.Conn
    send chan []byte
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true
            fmt.Println("Client connected")
            
        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
                fmt.Println("Client disconnected")
            }
            
        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (c *Client) readPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()
    
    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            break
        }
        c.hub.broadcast <- message
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            c.conn.WriteMessage(websocket.TextMessage, message)
        }
    }
}

func serveWS(hub *Hub, w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        return
    }
    
    client := &Client{
        hub:  hub,
        conn: conn,
        send: make(chan []byte, 256),
    }
    
    client.hub.register <- client
    
    go client.readPump()
    go client.writePump()
}

func main() {
    hub := &Hub{
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
        clients:    make(map[*Client]bool),
    }
    
    go hub.Run()
    
    http.HandleFunc("/ws", func(w http.ResponseWriter, r *http.Request) {
        serveWS(hub, w, r)
    })
    
    fmt.Println("Chat server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**ë¬¸ì œ 97**: ë¶„ì‚° ì›Œë“œì¹´ìš´íŠ¸ (MapReduce ìŠ¤íƒ€ì¼)
```go
// ë‹µì•ˆ
import (
    "strings"
    "unicode"
)

type KeyValue struct {
    Key   string
    Value string
}

func Map(filename, contents string) []KeyValue {
    ff := func(r rune) bool { return !unicode.IsLetter(r) }
    words := strings.FieldsFunc(contents, ff)
    
    var kva []KeyValue
    for _, w := range words {
        kv := KeyValue{strings.ToLower(w), "1"}
        kva = append(kva, kv)
    }
    return kva
}

func Reduce(key string, values []string) string {
    return fmt.Sprintf("%d", len(values))
}

func distributedWordCount(texts []string) map[string]int {
    // Map ë‹¨ê³„
    mapResults := make(chan []KeyValue, len(texts))
    var wg sync.WaitGroup
    
    for i, text := range texts {
        wg.Add(1)
        go func(id int, content string) {
            defer wg.Done()
            result := Map(fmt.Sprintf("text-%d", id), content)
            mapResults <- result
        }(i, text)
    }
    
    go func() {
        wg.Wait()
        close(mapResults)
    }()
    
    // ì¤‘ê°„ ê²°ê³¼ ìˆ˜ì§‘ ë° ê·¸ë£¹í™”
    intermediate := make(map[string][]string)
    for kvs := range mapResults {
        for _, kv := range kvs {
            intermediate[kv.Key] = append(intermediate[kv.Key], kv.Value)
        }
    }
    
    // Reduce ë‹¨ê³„
    result := make(map[string]int)
    reduceResults := make(chan struct {
        key   string
        count int
    }, len(intermediate))
    
    wg = sync.WaitGroup{}
    for key, values := range intermediate {
        wg.Add(1)
        go func(k string, vals []string) {
            defer wg.Done()
            countStr := Reduce(k, vals)
            count, _ := strconv.Atoi(countStr)
            reduceResults <- struct {
                key   string
                count int
            }{k, count}
        }(key, values)
    }
    
    go func() {
        wg.Wait()
        close(reduceResults)
    }()
    
    for r := range reduceResults {
        result[r.key] = r.count
    }
    
    return result
}

func main() {
    texts := []string{
        "hello world hello",
        "world of go programming",
        "go is awesome go go",
    }
    
    result := distributedWordCount(texts)
    
    fmt.Println("Word count results:")
    for word, count := range result {
        fmt.Printf("%s: %d\n", word, count)
    }
}
```

**ë¬¸ì œ 98**: ìºì‹œ ì„œë²„ (LRU ìºì‹œ)
```go
// ë‹µì•ˆ
type Node struct {
    key, value string
    prev, next *Node
}

type LRUCache struct {
    capacity int
    cache    map[string]*Node
    head     *Node
    tail     *Node
    mutex    sync.RWMutex
}

func NewLRUCache(capacity int) *LRUCache {
    head := &Node{}
    tail := &Node{}
    head.next = tail
    tail.prev = head
    
    return &LRUCache{
        capacity: capacity,
        cache:    make(map[string]*Node),
        head:     head,
        tail:     tail,
    }
}

func (c *LRUCache) addNode(node *Node) {
    node.prev = c.head
    node.next = c.head.next
    c.head.next.prev = node
    c.head.next = node
}

func (c *LRUCache) removeNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (c *LRUCache) moveToHead(node *Node) {
    c.removeNode(node)
    c.addNode(node)
}

func (c *LRUCache) popTail() *Node {
    lastNode := c.tail.prev
    c.removeNode(lastNode)
    return lastNode
}

func (c *LRUCache) Get(key string) (string, bool) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    if node, exists := c.cache[key]; exists {
        c.moveToHead(node)
        return node.value, true
    }
    return "", false
}

func (c *LRUCache) Put(key, value string) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    if node, exists := c.cache[key]; exists {
        node.value = value
        c.moveToHead(node)
    } else {
        newNode := &Node{key: key, value: value}
        
        if len(c.cache) >= c.capacity {
            tail := c.popTail()
            delete(c.cache, tail.key)
        }
        
        c.cache[key] = newNode
        c.addNode(newNode)
    }
}

func (c *LRUCache) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    key := r.URL.Query().Get("key")
    
    switch r.Method {
    case "GET":
        if value, exists := c.Get(key); exists {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte(value))
        } else {
            w.WriteHeader(http.StatusNotFound)
            w.Write([]byte("Key not found"))
        }
        
    case "POST":
        value := r.URL.Query().Get("value")
        c.Put(key, value)
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
        
    default:
        w.WriteHeader(http.StatusMethodNotAllowed)
    }
}

func main() {
    cache := NewLRUCache(100)
    
    fmt.Println("Cache server starting on :8080")
    fmt.Println("GET /?key=mykey")
    fmt.Println("POST /?key=mykey&value=myvalue")
    
    log.Fatal(http.ListenAndServe(":8080", cache))
}
```

**ë¬¸ì œ 99**: ë¦¬ë” ì„ ì¶œ ì•Œê³ ë¦¬ì¦˜ (Raft ìŠ¤íƒ€ì¼)
```go
// ë‹µì•ˆ
import "math/rand"

type NodeState int

const (
    Follower NodeState = iota
    Candidate
    Leader
)

type Node struct {
    id          int
    state       NodeState
    currentTerm int
    votedFor    int
    votes       int
    peers       []*Node
    
    electionTimer  *time.Timer
    heartbeatTimer *time.Timer
    
    mutex sync.RWMutex
}

func NewNode(id int, peers []*Node) *Node {
    n := &Node{
        id:       id,
        state:    Follower,
        votedFor: -1,
        peers:    peers,
    }
    n.resetElectionTimer()
    return n
}

func (n *Node) resetElectionTimer() {
    timeout := time.Duration(150+rand.Intn(150)) * time.Millisecond
    if n.electionTimer != nil {
        n.electionTimer.Stop()
    }
    n.electionTimer = time.AfterFunc(timeout, n.startElection)
}

func (n *Node) startElection() {
    n.mutex.Lock()
    n.state = Candidate
    n.currentTerm++
    n.votedFor = n.id
    n.votes = 1
    term := n.currentTerm
    n.mutex.Unlock()
    
    fmt.Printf("Node %d starting election for term %d\n", n.id, term)
    
    votes := make(chan bool, len(n.peers))
    
    for _, peer := range n.peers {
        if peer.id != n.id {
            go func(p *Node) {
                vote := n.requestVote(p, term)
                votes <- vote
            }(peer)
        }
    }
    
    voteCount := 1
    for i := 0; i < len(n.peers)-1; i++ {
        if <-votes {
            voteCount++
        }
        
        if voteCount > len(n.peers)/2 {
            n.becomeLeader()
            return
        }
    }
    
    n.mutex.Lock()
    n.state = Follower
    n.mutex.Unlock()
    n.resetElectionTimer()
}

func (n *Node) requestVote(peer *Node, term int) bool {
    peer.mutex.Lock()
    defer peer.mutex.Unlock()
    
    if term < peer.currentTerm {
        return false
    }
    
    if term > peer.currentTerm {
        peer.currentTerm = term
        peer.votedFor = -1
        peer.state = Follower
    }
    
    if peer.votedFor == -1 || peer.votedFor == n.id {
        peer.votedFor = n.id
        peer.resetElectionTimer()
        return true
    }
    
    return false
}

func (n *Node) becomeLeader() {
    n.mutex.Lock()
    n.state = Leader
    n.mutex.Unlock()
    
    fmt.Printf("Node %d became leader for term %d\n", n.id, n.currentTerm)
    
    n.sendHeartbeats()
    n.heartbeatTimer = time.AfterFunc(50*time.Millisecond, n.sendHeartbeats)
}

func (n *Node) sendHeartbeats() {
    if n.state != Leader {
        return
    }
    
    for _, peer := range n.peers {
        if peer.id != n.id {
            go func(p *Node) {
                p.mutex.Lock()
                if n.currentTerm >= p.currentTerm {
                    p.currentTerm = n.currentTerm
                    p.state = Follower
                    p.resetElectionTimer()
                }
                p.mutex.Unlock()
            }(peer)
        }
    }
    
    if n.state == Leader {
        n.heartbeatTimer = time.AfterFunc(50*time.Millisecond, n.sendHeartbeats)
    }
}

func main() {
    const numNodes = 5
    nodes := make([]*Node, numNodes)
    
    // ëª¨ë“  ë…¸ë“œ ìƒì„±
    for i := 0; i < numNodes; i++ {
        nodes[i] = &Node{
            id:       i,
            state:    Follower,
            votedFor: -1,
            peers:    nodes,
        }
    }
    
    // ê° ë…¸ë“œ ì‹œì‘
    for _, node := range nodes {
        node.resetElectionTimer()
    }
    
    fmt.Println("Starting Raft leader election simulation...")
    time.Sleep(10 * time.Second)
}
```

**ë¬¸ì œ 100**: ê°„ë‹¨í•œ ë¶„ì‚° í‚¤-ê°’ ì €ì¥ì†Œ
```go
// ë‹µì•ˆ
type KVStore struct {
    data  map[string]string
    mutex sync.RWMutex
    peers []string
}

func NewKVStore(peers []string) *KVStore {
    return &KVStore{
        data:  make(map[string]string),
        peers: peers,
    }
}

func (kv *KVStore) Get(key string) (string, bool) {
    kv.mutex.RLock()
    defer kv.mutex.RUnlock()
    
    value, exists := kv.data[key]
    return value, exists
}

func (kv *KVStore) Put(key, value string) error {
    kv.mutex.Lock()
    kv.data[key] = value
    kv.mutex.Unlock()
    
    // ë‹¤ë¥¸ ë…¸ë“œë“¤ì—ê²Œ ë³µì œ
    return kv.replicate(key, value)
}

func (kv *KVStore) replicate(key, value string) error {
    var wg sync.WaitGroup
    errors := make(chan error, len(kv.peers))
    
    for _, peer := range kv.peers {
        wg.Add(1)
        go func(peerAddr string) {
            defer wg.Done()
            
            data := map[string]string{"key": key, "value": value}
            jsonData, _ := json.Marshal(data)
            
            resp, err := http.Post(
                "http://"+peerAddr+"/replicate",
                "application/json",
                bytes.NewBuffer(jsonData),
            )
            if err != nil {
                errors <- err
                return
            }
            defer resp.Body.Close()
            
            if resp.StatusCode != http.StatusOK {
                errors <- fmt.Errorf("replication failed for %s", peerAddr)
            }
        }(peer)
    }
    
    go func() {
        wg.Wait()
        close(errors)
    }()
    
    // ìµœì†Œ í•˜ë‚˜ì˜ ë³µì œ ì„±ê³µ í™•ì¸
    errorCount := 0
    for err := range errors {
        if err != nil {
            fmt.Printf("Replication error: %v\n", err)
            errorCount++
        }
    }
    
    if errorCount == len(kv.peers) {
        return fmt.Errorf("all replications failed")
    }
    
    return nil
}

func (kv *KVStore) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case "GET":
        key := r.URL.Query().Get("key")
        if value, exists := kv.Get(key); exists {
            w.WriteHeader(http.StatusOK)
            json.NewEncoder(w).Encode(map[string]string{"value": value})
        } else {
            w.WriteHeader(http.StatusNotFound)
            json.NewEncoder(w).Encode(map[string]string{"error": "Key not found"})
        }
        
    case "POST":
        var data map[string]string
        if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        
        key := data["key"]
        value := data["value"]
        
        if r.URL.Path == "/replicate" {
            // ë³µì œ ìš”ì²­ ì²˜ë¦¬ (ë¡œì»¬ë§Œ)
            kv.mutex.Lock()
            kv.data[key] = value
            kv.mutex.Unlock()
            w.WriteHeader(http.StatusOK)
        } else {
            // ì¼ë°˜ PUT ìš”ì²­ (ë³µì œ í¬í•¨)
            if err := kv.Put(key, value); err != nil {
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
            } else {
                w.WriteHeader(http.StatusOK)
                json.NewEncoder(w).Encode(map[string]string{"status": "success"})
            }
        }
        
    default:
        w.WriteHeader(http.StatusMethodNotAllowed)
    }
}

func main() {
    port := flag.String("port", "8080", "Server port")
    peers := flag.String("peers", "", "Comma-separated list of peer addresses")
    flag.Parse()
    
    var peerList []string
    if *peers != "" {
        peerList = strings.Split(*peers, ",")
    }
    
    store := NewKVStore(peerList)
    
    fmt.Printf("KV Store starting on port %s\n", *port)
    fmt.Printf("Peers: %v\n", peerList)
    
    log.Fatal(http.ListenAndServe(":"+*port, store))
}
```

---

## ğŸ¯ í•™ìŠµ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Level 1 ì™„ë£Œ (1-30) âœ…
- [ ] ë³€ìˆ˜ ì„ ì–¸ê³¼ íƒ€ì… ì‹œìŠ¤í…œ
- [ ] ì¡°ê±´ë¬¸ê³¼ ë°˜ë³µë¬¸ 
- [ ] ë°°ì—´ê³¼ ìŠ¬ë¼ì´ìŠ¤ ì¡°ì‘
- [ ] ë§µ ì‚¬ìš©ë²•ê³¼ ìˆœíšŒ

### Level 2 ì™„ë£Œ (31-60) âœ…  
- [ ] í•¨ìˆ˜ ì •ì˜ì™€ ê³ ê¸‰ ê¸°ëŠ¥
- [ ] êµ¬ì¡°ì²´ì™€ ë©”ì„œë“œ
- [ ] ì¸í„°í˜ì´ìŠ¤ì™€ ë‹¤í˜•ì„±
- [ ] JSON ì²˜ë¦¬

### Level 3 ì™„ë£Œ (61-85) âœ…
- [ ] ê³ ë£¨í‹´ ê¸°ë³¸ ì‚¬ìš©ë²•
- [ ] ì±„ë„ì„ í†µí•œ í†µì‹ 
- [ ] ë™ì‹œì„± ì œì–´ (Mutex, WaitGroup)
- [ ] ê³ ê¸‰ ë™ì‹œì„± íŒ¨í„´

### Level 4 ì™„ë£Œ (86-100) âœ…
- [ ] TCP/HTTP ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°
- [ ] RPC êµ¬í˜„
- [ ] WebSocket ì‹¤ì‹œê°„ í†µì‹ 
- [ ] ë¶„ì‚° ì‹œìŠ¤í…œ íŒ¨í„´

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

ì´ 100ë¬¸í•­ì„ ì™„ë£Œí–ˆë‹¤ë©´:
1. **MIT 6.824 Lab ì¤€ë¹„ ì™„ë£Œ!** 
2. **Go ì–¸ì–´ ì¤‘ê¸‰ ìˆ˜ì¤€ ë‹¬ì„±**
3. **ë¶„ì‚° ì‹œìŠ¤í…œ êµ¬í˜„ ê¸°ì´ˆ ì™„ì„±**

ì´ì œ ìì‹ ìˆê²Œ [[MIT_6824_ì£¼ë§_í•™ìŠµ_ê°€ì´ë“œ]]ì˜ **Phase 1**ìœ¼ë¡œ ë„˜ì–´ê°€ì„¸ìš”! ğŸ‰