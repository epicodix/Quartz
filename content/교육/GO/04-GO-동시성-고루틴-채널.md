---
title: GO ë™ì‹œì„± - ê³ ë£¨í‹´ê³¼ ì±„ë„
tags:
  - golang
  - goroutines
  - channels
  - concurrency
  - parallelism
aliases:
  - Go-Concurrency
  - Go-Goroutines
  - Go-Channels
date: 2025-11-26
category: êµìœ¡/GO/ê³ ê¸‰
status: ì™„ì„±
priority: ë†’ìŒ
---

# âš¡ GO ë™ì‹œì„± - ê³ ë£¨í‹´ê³¼ ì±„ë„

## ğŸ“‹ ëª©ì°¨
- [[#1. ê³ ë£¨í‹´ ê¸°ì´ˆ|1. ê³ ë£¨í‹´ ê¸°ì´ˆ]]
- [[#2. ì±„ë„ ê¸°ì´ˆ|2. ì±„ë„ ê¸°ì´ˆ]]
- [[#3. ì±„ë„ ê³ ê¸‰ íŒ¨í„´|3. ì±„ë„ ê³ ê¸‰ íŒ¨í„´]]
- [[#4. ë™ê¸°í™” ë„êµ¬|4. ë™ê¸°í™” ë„êµ¬]]
- [[#ğŸ¯ ì‹¤ìŠµ ì˜ˆì œ|ì‹¤ìŠµ ì˜ˆì œ]]

---

## 1. ê³ ë£¨í‹´ ê¸°ì´ˆ

### ğŸš€ ê³ ë£¨í‹´ì´ë€?

> [!note] ê³ ë£¨í‹´ (Goroutine)
> ê³ ë£¨í‹´ì€ Go ëŸ°íƒ€ì„ì—ì„œ ê´€ë¦¬í•˜ëŠ” ê²½ëŸ‰ ìŠ¤ë ˆë“œì…ë‹ˆë‹¤. OS ìŠ¤ë ˆë“œë³´ë‹¤ í›¨ì”¬ ê°€ë³ê³  ë¹ ë¥´ë©°, ìˆ˜ì²œ ê°œë¥¼ ë™ì‹œì— ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```go
package main

import (
    "fmt"
    "time"
    "runtime"
)

// ì¼ë°˜ í•¨ìˆ˜
func sayHello(name string) {
    for i := 0; i < 5; i++ {
        fmt.Printf("Hello from %s: %d\n", name, i)
        time.Sleep(100 * time.Millisecond)
    }
}

// ê³ ë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰í•  í•¨ìˆ˜
func sayHelloGoroutine(name string) {
    for i := 0; i < 5; i++ {
        fmt.Printf("[Goroutine] Hello from %s: %d\n", name, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func goroutineBasics() {
    fmt.Printf("Go version: %s\n", runtime.Version())
    fmt.Printf("CPU cores: %d\n", runtime.NumCPU())
    fmt.Printf("Initial goroutines: %d\n", runtime.NumGoroutine())
    
    // ì¼ë°˜ í•¨ìˆ˜ í˜¸ì¶œ (ìˆœì°¨ ì‹¤í–‰)
    fmt.Println("\n=== Sequential Execution ===")
    sayHello("Alice")
    sayHello("Bob")
    
    // ê³ ë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰ (ë™ì‹œ ì‹¤í–‰)
    fmt.Println("\n=== Concurrent Execution ===")
    go sayHelloGoroutine("Charlie")  // ê³ ë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰
    go sayHelloGoroutine("Diana")    // ê³ ë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰
    
    fmt.Printf("After launching goroutines: %d\n", runtime.NumGoroutine())
    
    // ê³ ë£¨í‹´ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    time.Sleep(1 * time.Second)
    
    fmt.Printf("Final goroutines: %d\n", runtime.NumGoroutine())
}
```

### ğŸ­ ìµëª… í•¨ìˆ˜ì™€ ê³ ë£¨í‹´

```go
func anonymousGoroutines() {
    fmt.Println("=== Anonymous Goroutines ===")
    
    // ìµëª… í•¨ìˆ˜ë¥¼ ê³ ë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰
    go func() {
        fmt.Println("Anonymous goroutine 1")
        time.Sleep(200 * time.Millisecond)
        fmt.Println("Anonymous goroutine 1 done")
    }()
    
    // ë§¤ê°œë³€ìˆ˜ê°€ ìˆëŠ” ìµëª… í•¨ìˆ˜
    go func(message string, count int) {
        for i := 0; i < count; i++ {
            fmt.Printf("Anonymous goroutine 2: %s %d\n", message, i)
            time.Sleep(150 * time.Millisecond)
        }
    }("Hello", 3)
    
    // í´ë¡œì € ì‚¬ìš© (ì£¼ì˜: ë³€ìˆ˜ ìº¡ì²˜)
    for i := 0; i < 3; i++ {
        // ì˜ëª»ëœ ì˜ˆì‹œ - ëª¨ë“  ê³ ë£¨í‹´ì´ ê°™ì€ i ê°’ì„ ì°¸ì¡°
        go func() {
            fmt.Printf("Wrong closure: %d\n", i)  // ëª¨ë‘ 3ì´ ì¶œë ¥ë  ìˆ˜ ìˆìŒ
        }()
        
        // ì˜¬ë°”ë¥¸ ì˜ˆì‹œ - ë§¤ê°œë³€ìˆ˜ë¡œ ê°’ ì „ë‹¬
        go func(num int) {
            fmt.Printf("Correct closure: %d\n", num)
        }(i)
        
        // ë˜ ë‹¤ë¥¸ ì˜¬ë°”ë¥¸ ì˜ˆì‹œ - ì§€ì—­ ë³€ìˆ˜ ìƒì„±
        i := i  // ì§€ì—­ ë³€ìˆ˜ë¡œ ë³µì‚¬
        go func() {
            fmt.Printf("Local copy: %d\n", i)
        }()
    }
    
    time.Sleep(1 * time.Second)
}
```

### ğŸ• ê³ ë£¨í‹´ ë¼ì´í”„ì‚¬ì´í´

```go
import (
    "context"
    "sync"
)

func goroutineLifecycle() {
    var wg sync.WaitGroup
    
    // 1. ì •ìƒ ì™„ë£Œë˜ëŠ” ê³ ë£¨í‹´
    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println("Task 1: Starting")
        time.Sleep(500 * time.Millisecond)
        fmt.Println("Task 1: Completed")
    }()
    
    // 2. ì»¨í…ìŠ¤íŠ¸ë¡œ ì·¨ì†Œë˜ëŠ” ê³ ë£¨í‹´
    ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
    defer cancel()
    
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        select {
        case <-time.After(1 * time.Second):
            fmt.Println("Task 2: Completed")
        case <-ctx.Done():
            fmt.Println("Task 2: Cancelled due to timeout")
        }
    }()
    
    // 3. ì±„ë„ì„ í†µí•œ ì¢…ë£Œ ì‹ í˜¸
    quit := make(chan bool)
    
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        for {
            select {
            case <-quit:
                fmt.Println("Task 3: Received quit signal")
                return
            default:
                fmt.Println("Task 3: Working...")
                time.Sleep(100 * time.Millisecond)
            }
        }
    }()
    
    // 200ms í›„ ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡
    time.Sleep(200 * time.Millisecond)
    quit <- true
    
    // ëª¨ë“  ê³ ë£¨í‹´ ì™„ë£Œ ëŒ€ê¸°
    wg.Wait()
    fmt.Println("All tasks completed")
}
```

---

## 2. ì±„ë„ ê¸°ì´ˆ

### ğŸ“¡ ì±„ë„ì´ë€?

> [!info] ì±„ë„ (Channel)
> ì±„ë„ì€ ê³ ë£¨í‹´ ê°„ í†µì‹ ì„ ìœ„í•œ íŒŒì´í”„ì…ë‹ˆë‹¤. íƒ€ì… ì•ˆì „í•˜ë©°, ë™ê¸°í™” ê¸°ëŠ¥ë„ ì œê³µí•©ë‹ˆë‹¤.

```go
func channelBasics() {
    // 1. ì±„ë„ ìƒì„±
    messages := make(chan string)     // unbuffered ì±„ë„
    numbers := make(chan int, 3)      // buffered ì±„ë„ (í¬ê¸° 3)
    
    // 2. ê³ ë£¨í‹´ì—ì„œ ì±„ë„ë¡œ ë°ì´í„° ì „ì†¡
    go func() {
        messages <- "Hello"           // ì±„ë„ì— ê°’ ì „ì†¡ (blocked until received)
        messages <- "World"
        close(messages)               // ì±„ë„ ë‹«ê¸°
    }()
    
    // 3. ì±„ë„ì—ì„œ ë°ì´í„° ìˆ˜ì‹ 
    for message := range messages {   // ì±„ë„ì´ ë‹«í ë•Œê¹Œì§€ ìˆ˜ì‹ 
        fmt.Println("Received:", message)
    }
    
    // 4. ë²„í¼ë“œ ì±„ë„ ì‚¬ìš©
    go func() {
        for i := 1; i <= 5; i++ {
            numbers <- i
            fmt.Printf("Sent: %d (buffer size: 3)\n", i)
        }
        close(numbers)
    }()
    
    // 5. ì±„ë„ ìˆ˜ì‹  íŒ¨í„´ë“¤
    
    // íŒ¨í„´ 1: rangeë¡œ ëª¨ë“  ê°’ ìˆ˜ì‹ 
    for num := range numbers {
        fmt.Printf("Received: %d\n", num)
        time.Sleep(200 * time.Millisecond)  // ì²˜ë¦¬ ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜
    }
    
    // íŒ¨í„´ 2: ok ë³€ìˆ˜ë¡œ ì±„ë„ ìƒíƒœ í™•ì¸
    testChannel := make(chan int, 1)
    testChannel <- 42
    close(testChannel)
    
    if value, ok := <-testChannel; ok {
        fmt.Printf("Channel is open, received: %d\n", value)
    } else {
        fmt.Println("Channel is closed")
    }
    
    if value, ok := <-testChannel; ok {
        fmt.Printf("Channel is open, received: %d\n", value)
    } else {
        fmt.Println("Channel is closed (no more values)")
    }
}
```

### ğŸ›ï¸ ì±„ë„ ë°©í–¥ì„±

```go
// ì±„ë„ ë°©í–¥ì„± ì§€ì •
func channelDirections() {
    messages := make(chan string)
    
    // send-only ì±„ë„ë¡œ ì „ë‹¬
    go sender(messages)
    
    // receive-only ì±„ë„ë¡œ ì „ë‹¬
    go receiver(messages)
    
    time.Sleep(1 * time.Second)
}

// send-only ì±„ë„ (chan<- string)
func sender(ch chan<- string) {
    messages := []string{"Hello", "Go", "Channels"}
    
    for _, message := range messages {
        ch <- message
        fmt.Printf("Sent: %s\n", message)
        time.Sleep(200 * time.Millisecond)
    }
    
    close(ch)
}

// receive-only ì±„ë„ (<-chan string)
func receiver(ch <-chan string) {
    for message := range ch {
        fmt.Printf("Received: %s\n", message)
    }
    fmt.Println("Receiver finished")
}
```

### ğŸ”„ select ë¬¸

> [!tip] select ë¬¸
> selectëŠ” ì—¬ëŸ¬ ì±„ë„ ì‘ì—… ì¤‘ ì‹¤í–‰ ê°€ëŠ¥í•œ ê²ƒì„ ì„ íƒí•˜ëŠ” Goì˜ íŠ¹ë³„í•œ ì œì–´ë¬¸ì…ë‹ˆë‹¤.

```go
func selectBasics() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    quit := make(chan bool)
    
    // ê³ ë£¨í‹´ 1: ch1ë¡œ ë°ì´í„° ì „ì†¡
    go func() {
        time.Sleep(200 * time.Millisecond)
        ch1 <- "Message from channel 1"
    }()
    
    // ê³ ë£¨í‹´ 2: ch2ë¡œ ë°ì´í„° ì „ì†¡
    go func() {
        time.Sleep(100 * time.Millisecond)
        ch2 <- "Message from channel 2"
    }()
    
    // ê³ ë£¨í‹´ 3: íƒ€ì„ì•„ì›ƒ í›„ ì¢…ë£Œ ì‹ í˜¸
    go func() {
        time.Sleep(500 * time.Millisecond)
        quit <- true
    }()
    
    // selectë¡œ ì—¬ëŸ¬ ì±„ë„ ë™ì‹œ ëŒ€ê¸°
    for {
        select {
        case msg1 := <-ch1:
            fmt.Printf("From ch1: %s\n", msg1)
            
        case msg2 := <-ch2:
            fmt.Printf("From ch2: %s\n", msg2)
            
        case <-quit:
            fmt.Println("Quit signal received")
            return
            
        case <-time.After(1 * time.Second):
            fmt.Println("Timeout - no message received")
            return
            
        default:
            fmt.Println("No channel is ready")
            time.Sleep(50 * time.Millisecond)
        }
    }
}
```

### ğŸ¯ ì±„ë„ì„ í™œìš©í•œ íŒ¨í„´ë“¤

```go
// 1. Fan-out: í•˜ë‚˜ì˜ ì…ë ¥ì„ ì—¬ëŸ¬ ê³ ë£¨í‹´ìœ¼ë¡œ ë¶„ì‚°
func fanOut(input <-chan int) (<-chan int, <-chan int) {
    out1 := make(chan int)
    out2 := make(chan int)
    
    go func() {
        defer close(out1)
        defer close(out2)
        
        for val := range input {
            // ë‘ ì±„ë„ë¡œ ë™ì‹œì— ì „ì†¡
            out1 <- val
            out2 <- val
        }
    }()
    
    return out1, out2
}

// 2. Fan-in: ì—¬ëŸ¬ ì…ë ¥ì„ í•˜ë‚˜ì˜ ì±„ë„ë¡œ ë³‘í•©
func fanIn(ch1, ch2 <-chan string) <-chan string {
    out := make(chan string)
    
    go func() {
        defer close(out)
        
        for {
            select {
            case msg, ok := <-ch1:
                if !ok {
                    ch1 = nil  // ë‹«íŒ ì±„ë„ì„ nilë¡œ ì„¤ì •í•´ì„œ selectì—ì„œ ì œì™¸
                } else {
                    out <- fmt.Sprintf("Ch1: %s", msg)
                }
            case msg, ok := <-ch2:
                if !ok {
                    ch2 = nil
                } else {
                    out <- fmt.Sprintf("Ch2: %s", msg)
                }
            }
            
            // ë‘ ì±„ë„ì´ ëª¨ë‘ ë‹«íˆë©´ ì¢…ë£Œ
            if ch1 == nil && ch2 == nil {
                break
            }
        }
    }()
    
    return out
}

// 3. Worker Pool íŒ¨í„´
func workerPool() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // ì›Œì»¤ 3ê°œ ì‹œì‘
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // ì‘ì—… ì „ì†¡
    for j := 1; j <= 9; j++ {
        jobs <- j
    }
    close(jobs)
    
    // ê²°ê³¼ ìˆ˜ì§‘
    for r := 1; r <= 9; r++ {
        result := <-results
        fmt.Printf("Result: %d\n", result)
    }
}

func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job)
        time.Sleep(200 * time.Millisecond)  // ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
        results <- job * job
    }
}

func channelPatterns() {
    fmt.Println("=== Fan-out Pattern ===")
    input := make(chan int, 3)
    
    // ì…ë ¥ ë°ì´í„° ìƒì„±
    go func() {
        defer close(input)
        for i := 1; i <= 3; i++ {
            input <- i
        }
    }()
    
    out1, out2 := fanOut(input)
    
    // ë‘ ì¶œë ¥ ì±„ë„ì—ì„œ ë°ì´í„° ìˆ˜ì‹ 
    go func() {
        for val := range out1 {
            fmt.Printf("Out1 received: %d\n", val)
        }
    }()
    
    go func() {
        for val := range out2 {
            fmt.Printf("Out2 received: %d\n", val)
        }
    }()
    
    time.Sleep(500 * time.Millisecond)
    
    fmt.Println("\n=== Fan-in Pattern ===")
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        defer close(ch1)
        for i := 1; i <= 3; i++ {
            ch1 <- fmt.Sprintf("Message %d", i)
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    go func() {
        defer close(ch2)
        for i := 1; i <= 3; i++ {
            ch2 <- fmt.Sprintf("Data %d", i)
            time.Sleep(150 * time.Millisecond)
        }
    }()
    
    merged := fanIn(ch1, ch2)
    for msg := range merged {
        fmt.Printf("Merged: %s\n", msg)
    }
    
    fmt.Println("\n=== Worker Pool Pattern ===")
    workerPool()
}
```

---

## 3. ì±„ë„ ê³ ê¸‰ íŒ¨í„´

### ğŸª Pipeline íŒ¨í„´

```go
// íŒŒì´í”„ë¼ì¸ ë‹¨ê³„ë³„ í•¨ìˆ˜ë“¤
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, num := range nums {
            out <- num
        }
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for num := range in {
            out <- num * num
        }
    }()
    return out
}

func filter(in <-chan int, predicate func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for num := range in {
            if predicate(num) {
                out <- num
            }
        }
    }()
    return out
}

func pipelineExample() {
    fmt.Println("=== Pipeline Pattern ===")
    
    // íŒŒì´í”„ë¼ì¸ êµ¬ì„±: generate -> square -> filter
    numbers := generate(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    squared := square(numbers)
    evens := filter(squared, func(n int) bool { return n%2 == 0 })
    
    // ê²°ê³¼ ì¶œë ¥
    for result := range evens {
        fmt.Printf("Even square: %d\n", result)
    }
}
```

### ğŸ”„ Pub/Sub íŒ¨í„´

```go
import "sync"

type PubSub struct {
    mu          sync.RWMutex
    subscribers map[string][]chan<- string
}

func NewPubSub() *PubSub {
    return &PubSub{
        subscribers: make(map[string][]chan<- string),
    }
}

func (ps *PubSub) Subscribe(topic string) <-chan string {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    ch := make(chan string, 1)
    ps.subscribers[topic] = append(ps.subscribers[topic], ch)
    
    return ch
}

func (ps *PubSub) Publish(topic, message string) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    for _, ch := range ps.subscribers[topic] {
        // Non-blocking send
        select {
        case ch <- message:
        default:
            fmt.Printf("Subscriber buffer full, dropping message: %s\n", message)
        }
    }
}

func (ps *PubSub) Unsubscribe(topic string, ch <-chan string) {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    subscribers := ps.subscribers[topic]
    for i, subscriber := range subscribers {
        if subscriber == ch {
            // Remove from slice
            ps.subscribers[topic] = append(subscribers[:i], subscribers[i+1:]...)
            close(subscriber)
            break
        }
    }
}

func pubSubExample() {
    fmt.Println("=== Pub/Sub Pattern ===")
    
    pubsub := NewPubSub()
    
    // êµ¬ë…ì 1: ë‰´ìŠ¤ í† í”½
    newsSubscriber1 := pubsub.Subscribe("news")
    go func() {
        for msg := range newsSubscriber1 {
            fmt.Printf("News Subscriber 1: %s\n", msg)
        }
    }()
    
    // êµ¬ë…ì 2: ë‰´ìŠ¤ í† í”½
    newsSubscriber2 := pubsub.Subscribe("news")
    go func() {
        for msg := range newsSubscriber2 {
            fmt.Printf("News Subscriber 2: %s\n", msg)
        }
    }()
    
    // êµ¬ë…ì 3: ìŠ¤í¬ì¸  í† í”½
    sportsSubscriber := pubsub.Subscribe("sports")
    go func() {
        for msg := range sportsSubscriber {
            fmt.Printf("Sports Subscriber: %s\n", msg)
        }
    }()
    
    // ë©”ì‹œì§€ ë°œí–‰
    time.Sleep(100 * time.Millisecond)  // êµ¬ë…ì ì¤€ë¹„ ì‹œê°„
    
    pubsub.Publish("news", "Breaking: Go 1.22 Released!")
    pubsub.Publish("sports", "Football: Team A wins 3-0")
    pubsub.Publish("news", "Tech: New AI Model Announced")
    pubsub.Publish("weather", "Sunny day ahead")  // êµ¬ë…ì ì—†ìŒ
    
    time.Sleep(500 * time.Millisecond)
}
```

### âš¡ Rate Limiting íŒ¨í„´

```go
import "golang.org/x/time/rate"

// í† í° ë²„í‚·ì„ ì´ìš©í•œ Rate Limiter
type TokenBucket struct {
    tokens chan struct{}
    ticker *time.Ticker
}

func NewTokenBucket(capacity int, refillRate time.Duration) *TokenBucket {
    tb := &TokenBucket{
        tokens: make(chan struct{}, capacity),
        ticker: time.NewTicker(refillRate),
    }
    
    // ì´ˆê¸° í† í° ì±„ìš°ê¸°
    for i := 0; i < capacity; i++ {
        tb.tokens <- struct{}{}
    }
    
    // ì£¼ê¸°ì ìœ¼ë¡œ í† í° ë³´ì¶©
    go func() {
        for range tb.ticker.C {
            select {
            case tb.tokens <- struct{}{}:
            default:
                // ë²„í‚·ì´ ê°€ë“ ì°¨ë©´ ë¬´ì‹œ
            }
        }
    }()
    
    return tb
}

func (tb *TokenBucket) TakeToken() bool {
    select {
    case <-tb.tokens:
        return true
    default:
        return false
    }
}

func (tb *TokenBucket) Stop() {
    tb.ticker.Stop()
}

// Rate limiterë¥¼ ì‚¬ìš©í•œ API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
func rateLimitingExample() {
    fmt.Println("=== Rate Limiting Pattern ===")
    
    // 1ì´ˆì— 3ê°œ í† í°, ìµœëŒ€ 5ê°œ í† í° ë³´ìœ  ê°€ëŠ¥
    limiter := NewTokenBucket(5, 333*time.Millisecond)
    defer limiter.Stop()
    
    // 10ê°œì˜ API ìš”ì²­ ì‹œë®¬ë ˆì´ì…˜
    for i := 1; i <= 10; i++ {
        if limiter.TakeToken() {
            fmt.Printf("API Request %d: Allowed\n", i)
            
            // API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            go func(reqID int) {
                time.Sleep(100 * time.Millisecond)
                fmt.Printf("API Request %d: Completed\n", reqID)
            }(i)
        } else {
            fmt.Printf("API Request %d: Rate limited\n", i)
        }
        
        time.Sleep(200 * time.Millisecond)  // ìš”ì²­ ê°„ê²©
    }
    
    time.Sleep(2 * time.Second)
    
    // Goì˜ rate íŒ¨í‚¤ì§€ ì‚¬ìš© ì˜ˆì œ
    fmt.Println("\n=== Using golang.org/x/time/rate ===")
    
    // ì´ˆë‹¹ 2ê°œ, ë²„ìŠ¤íŠ¸ 5ê°œ
    rl := rate.NewLimiter(rate.Limit(2), 5)
    
    for i := 1; i <= 8; i++ {
        if rl.Allow() {
            fmt.Printf("Request %d: Allowed\n", i)
        } else {
            fmt.Printf("Request %d: Rate limited\n", i)
        }
        time.Sleep(300 * time.Millisecond)
    }
}
```

---

## 4. ë™ê¸°í™” ë„êµ¬

### ğŸ”’ Mutexì™€ RWMutex

```go
import (
    "math/rand"
    "sync"
)

type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (sc *SafeCounter) Increment() {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    sc.value++
}

func (sc *SafeCounter) GetValue() int {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    return sc.value
}

type SafeMap struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]int),
    }
}

func (sm *SafeMap) Set(key string, value int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.data[key] = value
}

func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mu.RLock()  // ì½ê¸° ì „ìš© ë½
    defer sm.mu.RUnlock()
    value, ok := sm.data[key]
    return value, ok
}

func (sm *SafeMap) GetAll() map[string]int {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    
    // ë³µì‚¬ë³¸ ë°˜í™˜
    result := make(map[string]int)
    for k, v := range sm.data {
        result[k] = v
    }
    return result
}

func mutexExample() {
    fmt.Println("=== Mutex Example ===")
    
    counter := &SafeCounter{}
    var wg sync.WaitGroup
    
    // 10ê°œ ê³ ë£¨í‹´ì´ ë™ì‹œì— ì¹´ìš´í„° ì¦ê°€
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 100; j++ {
                counter.Increment()
            }
            fmt.Printf("Goroutine %d finished\n", id)
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("Final counter value: %d\n", counter.GetValue())
    
    fmt.Println("\n=== RWMutex Example ===")
    
    safeMap := NewSafeMap()
    
    // ë°ì´í„° ì“°ê¸° ê³ ë£¨í‹´
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            key := fmt.Sprintf("key%d", i)
            value := rand.Intn(100)
            safeMap.Set(key, value)
            fmt.Printf("Set %s = %d\n", key, value)
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    // ë°ì´í„° ì½ê¸° ê³ ë£¨í‹´ë“¤
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 10; j++ {
                all := safeMap.GetAll()
                fmt.Printf("Reader %d: %v\n", id, all)
                time.Sleep(100 * time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
}
```

### ğŸ¯ sync.Onceì™€ sync.Pool

```go
type Singleton struct {
    value string
}

var (
    instance *Singleton
    once     sync.Once
)

func GetSingleton() *Singleton {
    once.Do(func() {
        fmt.Println("Creating singleton instance")
        instance = &Singleton{value: "I am singleton"}
    })
    return instance
}

func syncOnceExample() {
    fmt.Println("=== sync.Once Example ===")
    
    var wg sync.WaitGroup
    
    // ì—¬ëŸ¬ ê³ ë£¨í‹´ì´ ë™ì‹œì— ì‹±ê¸€í†¤ ì ‘ê·¼
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            s := GetSingleton()
            fmt.Printf("Goroutine %d: %s\n", id, s.value)
        }(i)
    }
    
    wg.Wait()
}

// sync.Pool ì˜ˆì œ
type ExpensiveObject struct {
    data [1000]byte
}

var objectPool = sync.Pool{
    New: func() interface{} {
        fmt.Println("Creating new expensive object")
        return &ExpensiveObject{}
    },
}

func useExpensiveObject() {
    // í’€ì—ì„œ ê°ì²´ ê°€ì ¸ì˜¤ê¸°
    obj := objectPool.Get().(*ExpensiveObject)
    
    // ì‚¬ìš©
    fmt.Println("Using expensive object")
    time.Sleep(100 * time.Millisecond)
    
    // ë‹¤ì‹œ í’€ì— ë°˜í™˜
    objectPool.Put(obj)
}

func syncPoolExample() {
    fmt.Println("\n=== sync.Pool Example ===")
    
    var wg sync.WaitGroup
    
    // ì—¬ëŸ¬ ê³ ë£¨í‹´ì´ ê°ì²´ ì‚¬ìš©
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("Goroutine %d ", id)
            useExpensiveObject()
        }(i)
    }
    
    wg.Wait()
}
```

---

## ğŸ¯ ì‹¤ìŠµ ì˜ˆì œ

### ğŸ“ ì—°ìŠµ ë¬¸ì œ 1: ì›¹ í¬ë¡¤ëŸ¬

```go
package main

import (
    "fmt"
    "net/http"
    "sync"
    "time"
)

type CrawlResult struct {
    URL        string
    StatusCode int
    Error      error
    Duration   time.Duration
}

type WebCrawler struct {
    maxWorkers   int
    visitedMutex sync.Mutex
    visited      map[string]bool
    results      chan CrawlResult
}

func NewWebCrawler(maxWorkers int) *WebCrawler {
    return &WebCrawler{
        maxWorkers: maxWorkers,
        visited:    make(map[string]bool),
        results:    make(chan CrawlResult),
    }
}

func (wc *WebCrawler) isVisited(url string) bool {
    wc.visitedMutex.Lock()
    defer wc.visitedMutex.Unlock()
    
    if wc.visited[url] {
        return true
    }
    wc.visited[url] = true
    return false
}

func (wc *WebCrawler) crawlURL(url string) {
    if wc.isVisited(url) {
        return
    }
    
    start := time.Now()
    resp, err := http.Get(url)
    duration := time.Since(start)
    
    result := CrawlResult{
        URL:      url,
        Duration: duration,
        Error:    err,
    }
    
    if err == nil {
        result.StatusCode = resp.StatusCode
        resp.Body.Close()
    }
    
    wc.results <- result
}

func (wc *WebCrawler) Crawl(urls []string) []CrawlResult {
    jobs := make(chan string, len(urls))
    var wg sync.WaitGroup
    
    // ì›Œì»¤ ì‹œì‘
    for i := 0; i < wc.maxWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for url := range jobs {
                wc.crawlURL(url)
            }
        }()
    }
    
    // ê²°ê³¼ ìˆ˜ì§‘ ê³ ë£¨í‹´
    var results []CrawlResult
    done := make(chan bool)
    go func() {
        for result := range wc.results {
            results = append(results, result)
            if len(results) == len(urls) {
                done <- true
                break
            }
        }
    }()
    
    // URL ì‘ì—… ì „ì†¡
    for _, url := range urls {
        jobs <- url
    }
    close(jobs)
    
    // ì™„ë£Œ ëŒ€ê¸°
    <-done
    wg.Wait()
    close(wc.results)
    
    return results
}

func webCrawlerExample() {
    fmt.Println("=== Web Crawler Example ===")
    
    urls := []string{
        "https://golang.org",
        "https://github.com",
        "https://stackoverflow.com",
        "https://reddit.com",
        "https://news.ycombinator.com",
        "https://invalid-url-that-should-fail.com",
    }
    
    crawler := NewWebCrawler(3)  // 3ê°œ ì›Œì»¤
    results := crawler.Crawl(urls)
    
    fmt.Printf("\nCrawl Results (%d URLs):\n", len(results))
    fmt.Println("----------------------------------------")
    
    for _, result := range results {
        status := fmt.Sprintf("Status: %d", result.StatusCode)
        if result.Error != nil {
            status = fmt.Sprintf("Error: %v", result.Error)
        }
        
        fmt.Printf("%-30s | %-20s | Duration: %v\n", 
            result.URL, status, result.Duration)
    }
}
```

### ğŸ“ ì—°ìŠµ ë¬¸ì œ 2: ì‹¤ì‹œê°„ ë¡œê·¸ í”„ë¡œì„¸ì„œ

```go
import (
    "bufio"
    "regexp"
    "strings"
)

type LogEntry struct {
    Timestamp string
    Level     string
    Message   string
    Raw       string
}

type LogProcessor struct {
    logPattern *regexp.Regexp
    filters    []LogFilter
    processors []chan LogEntry
    stats      *LogStats
}

type LogFilter func(LogEntry) bool

type LogStats struct {
    mu                    sync.RWMutex
    totalLogs            int
    logsByLevel          map[string]int
    errorPatterns        map[string]int
}

func NewLogStats() *LogStats {
    return &LogStats{
        logsByLevel:   make(map[string]int),
        errorPatterns: make(map[string]int),
    }
}

func (ls *LogStats) Record(entry LogEntry) {
    ls.mu.Lock()
    defer ls.mu.Unlock()
    
    ls.totalLogs++
    ls.logsByLevel[entry.Level]++
    
    // ì—ëŸ¬ íŒ¨í„´ ê°ì§€
    if entry.Level == "ERROR" {
        if strings.Contains(entry.Message, "database") {
            ls.errorPatterns["database"]++
        } else if strings.Contains(entry.Message, "network") {
            ls.errorPatterns["network"]++
        } else if strings.Contains(entry.Message, "timeout") {
            ls.errorPatterns["timeout"]++
        }
    }
}

func (ls *LogStats) GetStats() map[string]interface{} {
    ls.mu.RLock()
    defer ls.mu.RUnlock()
    
    return map[string]interface{}{
        "total_logs":     ls.totalLogs,
        "logs_by_level":  copyMap(ls.logsByLevel),
        "error_patterns": copyMap(ls.errorPatterns),
    }
}

func copyMap(m map[string]int) map[string]int {
    result := make(map[string]int)
    for k, v := range m {
        result[k] = v
    }
    return result
}

func NewLogProcessor() *LogProcessor {
    // ë¡œê·¸ íŒ¨í„´: 2025-11-26 10:30:45 [INFO] Message
    pattern := regexp.MustCompile(`(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(\w+)\] (.+)`)
    
    return &LogProcessor{
        logPattern: pattern,
        stats:      NewLogStats(),
    }
}

func (lp *LogProcessor) AddFilter(filter LogFilter) {
    lp.filters = append(lp.filters, filter)
}

func (lp *LogProcessor) AddProcessor(processor chan LogEntry) {
    lp.processors = append(lp.processors, processor)
}

func (lp *LogProcessor) ParseLog(line string) *LogEntry {
    matches := lp.logPattern.FindStringSubmatch(line)
    if len(matches) != 4 {
        return nil
    }
    
    return &LogEntry{
        Timestamp: matches[1],
        Level:     matches[2],
        Message:   matches[3],
        Raw:       line,
    }
}

func (lp *LogProcessor) ProcessLogs(logLines []string) {
    var wg sync.WaitGroup
    
    // í”„ë¡œì„¸ì„œ ê³ ë£¨í‹´ë“¤ ì‹œì‘
    for i, processor := range lp.processors {
        wg.Add(1)
        go func(id int, ch chan LogEntry) {
            defer wg.Done()
            fmt.Printf("Processor %d started\n", id)
            
            for entry := range ch {
                // í”„ë¡œì„¸ì„œë³„ ë¡œì§ (ì—¬ê¸°ì„œëŠ” ì¶œë ¥ë§Œ)
                fmt.Printf("Processor %d: [%s] %s - %s\n", 
                    id, entry.Level, entry.Timestamp, entry.Message)
                time.Sleep(50 * time.Millisecond)  // ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
            }
            
            fmt.Printf("Processor %d finished\n", id)
        }(i, processor)
    }
    
    // ë¡œê·¸ ì²˜ë¦¬
    for _, line := range logLines {
        entry := lp.ParseLog(line)
        if entry == nil {
            continue
        }
        
        // í•„í„° ì ìš©
        passed := true
        for _, filter := range lp.filters {
            if !filter(*entry) {
                passed = false
                break
            }
        }
        
        if !passed {
            continue
        }
        
        // í†µê³„ ê¸°ë¡
        lp.stats.Record(*entry)
        
        // ëª¨ë“  í”„ë¡œì„¸ì„œì— ì „ì†¡
        for _, processor := range lp.processors {
            processor <- *entry
        }
    }
    
    // í”„ë¡œì„¸ì„œ ì±„ë„ ë‹«ê¸°
    for _, processor := range lp.processors {
        close(processor)
    }
    
    wg.Wait()
}

func logProcessorExample() {
    fmt.Println("=== Log Processor Example ===")
    
    // ìƒ˜í”Œ ë¡œê·¸ ë°ì´í„°
    logLines := []string{
        "2025-11-26 10:30:45 [INFO] Application started",
        "2025-11-26 10:30:46 [DEBUG] Loading configuration",
        "2025-11-26 10:30:47 [INFO] Database connected",
        "2025-11-26 10:30:48 [WARN] High memory usage detected",
        "2025-11-26 10:30:49 [ERROR] Database connection timeout",
        "2025-11-26 10:30:50 [ERROR] Network error: connection refused",
        "2025-11-26 10:30:51 [INFO] User logged in",
        "2025-11-26 10:30:52 [ERROR] Database query failed",
        "Invalid log line",
        "2025-11-26 10:30:53 [INFO] Request processed successfully",
    }
    
    processor := NewLogProcessor()
    
    // í•„í„° ì¶”ê°€: DEBUG ë ˆë²¨ ì œì™¸
    processor.AddFilter(func(entry LogEntry) bool {
        return entry.Level != "DEBUG"
    })
    
    // í”„ë¡œì„¸ì„œ ì¶”ê°€
    errorProcessor := make(chan LogEntry, 10)
    infoProcessor := make(chan LogEntry, 10)
    
    processor.AddProcessor(errorProcessor)
    processor.AddProcessor(infoProcessor)
    
    // ë¡œê·¸ ì²˜ë¦¬ ì‹¤í–‰
    processor.ProcessLogs(logLines)
    
    // í†µê³„ ì¶œë ¥
    fmt.Println("\n=== Log Statistics ===")
    stats := processor.stats.GetStats()
    
    fmt.Printf("Total logs processed: %v\n", stats["total_logs"])
    fmt.Printf("Logs by level: %v\n", stats["logs_by_level"])
    fmt.Printf("Error patterns: %v\n", stats["error_patterns"])
}
```

---

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê³ ë£¨í‹´
- [ ] ê³ ë£¨í‹´ ê¸°ë³¸ ê°œë…ê³¼ ìƒì„±
- [ ] ìµëª… í•¨ìˆ˜ì™€ ê³ ë£¨í‹´
- [ ] í´ë¡œì €ì™€ ë³€ìˆ˜ ìº¡ì²˜ ì£¼ì˜ì‚¬í•­
- [ ] ê³ ë£¨í‹´ ìƒëª…ì£¼ê¸° ê´€ë¦¬

### ì±„ë„
- [ ] ì±„ë„ ê¸°ë³¸ ì‚¬ìš©ë²•
- [ ] ë²„í¼ë“œ vs ì–¸ë²„í¼ë“œ ì±„ë„
- [ ] ì±„ë„ ë°©í–¥ì„± ì§€ì •
- [ ] select ë¬¸ í™œìš©

### ë™ì‹œì„± íŒ¨í„´
- [ ] Fan-out/Fan-in íŒ¨í„´
- [ ] Worker Pool íŒ¨í„´
- [ ] Pipeline íŒ¨í„´
- [ ] Pub/Sub íŒ¨í„´

### ë™ê¸°í™”
- [ ] Mutexì™€ RWMutex
- [ ] sync.Onceì™€ sync.Pool
- [ ] WaitGroup ì‚¬ìš©ë²•
- [ ] Contextë¥¼ í†µí•œ ì·¨ì†Œ

---

> [!tip] ë‹¤ìŒ ë‹¨ê³„
> ë™ì‹œì„±ì„ ìµí˜”ë‹¤ë©´ [[05-GO-ì‹¤ì „-REST-API-í”„ë¡œì íŠ¸|GO ì‹¤ì „ REST API í”„ë¡œì íŠ¸]]ë¡œ ë„˜ì–´ê°€ì„¸ìš”!