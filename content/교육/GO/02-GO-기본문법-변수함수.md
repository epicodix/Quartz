---
title: GO κΈ°λ³Έλ¬Έλ²• - λ³€μμ™€ ν•¨μ
tags:
  - golang
  - variables
  - functions
  - syntax
  - basics
aliases:
  - Go-Variables
  - Go-Functions
  - GO-κΈ°λ³Έλ¬Έλ²•
date: 2025-11-26
category: κµμ΅/GO/κΈ°μ΄
status: μ™„μ„±
priority: λ†’μ
---

# π“ GO κΈ°λ³Έλ¬Έλ²• - λ³€μμ™€ ν•¨μ

## π“‹ λ©μ°¨
- [[#1. λ³€μ μ„ μ–Έ|1. λ³€μ μ„ μ–Έ]]
- [[#2. ν•¨μ μ •μ|2. ν•¨μ μ •μ]]
- [[#3. μ—λ¬ μ²λ¦¬|3. μ—λ¬ μ²λ¦¬]]
- [[#4. ν¬μΈν„° κΈ°μ΄|4. ν¬μΈν„° κΈ°μ΄]]
- [[#π― μ‹¤μµ μμ |μ‹¤μµ μμ ]]

---

## 1. λ³€μ μ„ μ–Έ

### π’΅ λ³€μ μ„ μ–Έμ 4κ°€μ§€ λ°©λ²•

#### 1. **λ…μ‹μ  μ„ μ–Έ (var ν‚¤μ›λ“)**
```go
package main

import "fmt"

func main() {
    // νƒ€μ…κ³Ό ν•¨κ» μ„ μ–Έ
    var name string = "Go"
    var age int = 13
    var isActive bool = true
    
    // κΈ°λ³Έκ°’μΌλ΅ μ΄κΈ°ν™” (zero value)
    var count int      // 0
    var message string // ""
    var flag bool      // false
    
    fmt.Printf("Name: %s, Age: %d, Active: %t\n", name, age, isActive)
    fmt.Printf("Count: %d, Message: '%s', Flag: %t\n", count, message, flag)
}
```

#### 2. **νƒ€μ… μ¶”λ΅  (var ν‚¤μ›λ“ + μ¶”λ΅ )**
```go
func variableInference() {
    // Goκ°€ νƒ€μ…μ„ μλ™μΌλ΅ μ¶”λ΅ 
    var language = "Golang"     // stringμΌλ΅ μ¶”λ΅ 
    var version = 1.21          // float64λ΅ μ¶”λ΅ 
    var downloads = 1000000     // intλ΅ μ¶”λ΅ 
    
    fmt.Printf("Language: %s (Type: %T)\n", language, language)
    fmt.Printf("Version: %.1f (Type: %T)\n", version, version)
    fmt.Printf("Downloads: %d (Type: %T)\n", downloads, downloads)
}
```

#### 3. **μ§§μ€ μ„ μ–Έ (Short Declaration)**
```go
func shortDeclaration() {
    // ν•¨μ λ‚΄λ¶€μ—μ„λ§ μ‚¬μ© κ°€λ¥!
    nickname := "Gopher"
    year := 2025
    pi := 3.14159
    
    // ν• μ¤„μ— μ—¬λ¬ λ³€μ μ„ μ–Έ
    x, y := 10, 20
    firstName, lastName := "John", "Doe"
    
    fmt.Printf("Nickname: %s, Year: %d, Pi: %.2f\n", nickname, year, pi)
    fmt.Printf("Coordinates: (%d, %d)\n", x, y)
    fmt.Printf("Full Name: %s %s\n", firstName, lastName)
}
```

#### 4. **κ·Έλ£Ή μ„ μ–Έ**
```go
var (
    // ν¨ν‚¤μ§€ λ λ²¨ λ³€μλ“¤
    appName    = "MyGoApp"
    version    = "1.0.0"
    maxUsers   = 1000
    isDebug    = false
)

func groupDeclaration() {
    // ν•¨μ λ‚΄λ¶€ κ·Έλ£Ή μ„ μ–Έ
    var (
        width  = 1920
        height = 1080
        fps    = 60
    )
    
    fmt.Printf("App: %s v%s, Max Users: %d\n", appName, version, maxUsers)
    fmt.Printf("Resolution: %dx%d@%dfps\n", width, height, fps)
}
```

### π”„ λ³€μ μ¬ν• λ‹Ή

```go
func reassignment() {
    // λ³€μ κ°’ λ³€κ²½
    var score int = 0
    score = 100  // μ¬ν• λ‹Ή
    score += 25  // score = score + 25
    
    // μ§§μ€ μ„ μ–ΈμΌλ΅ μƒ λ³€μ μ¶”κ°€
    name := "Alice"
    name, age := "Bob", 30  // nameμ€ μ¬ν• λ‹Ή, ageλ” μƒ μ„ μ–Έ
    
    fmt.Printf("Score: %d\n", score)
    fmt.Printf("Name: %s, Age: %d\n", name, age)
}
```

### π“ κΈ°λ³Έ λ°μ΄ν„° νƒ€μ…

```go
func dataTypes() {
    // μ •μν•
    var smallInt int8 = 127           // -128 ~ 127
    var mediumInt int16 = 32767       // -32768 ~ 32767
    var normalInt int32 = 2147483647  // -2^31 ~ 2^31-1
    var bigInt int64 = 9223372036854775807 // -2^63 ~ 2^63-1
    var autoInt int = 42              // ν”λ«νΌμ— λ”°λΌ 32bit λλ” 64bit
    
    // λ¶€νΈ μ—†λ” μ •μν•
    var uSmall uint8 = 255            // 0 ~ 255 (byteμ™€ κ°™μ)
    var uMedium uint16 = 65535        // 0 ~ 65535
    var uNormal uint32 = 4294967295   // 0 ~ 2^32-1
    var uBig uint64 = 18446744073709551615 // 0 ~ 2^64-1
    
    // μ‹¤μν•
    var precision float32 = 3.14159   // 32bit λ¶€λ™μ†μμ 
    var doublePrecision float64 = 3.141592653589793 // 64bit λ¶€λ™μ†μμ 
    
    // λ¬Έμμ—΄κ³Ό λ¬Έμ
    var text string = "Hello, Go!"   // UTF-8 λ¬Έμμ—΄
    var char rune = 'G'              // Unicode μ½”λ“ ν¬μΈνΈ (int32 λ³„μΉ­)
    var byteVal byte = 65            // uint8 λ³„μΉ­ (ASCII 'A')
    
    // λ¶λ¦°
    var isReady bool = true          // true λλ” false
    
    // λ³µμ†μ (μ μ• μ”€)
    var complexNum complex64 = 1 + 2i
    var bigComplexNum complex128 = 1 + 2i
    
    fmt.Printf("Integer types: %d, %d, %d, %d, %d\n", 
        smallInt, mediumInt, normalInt, bigInt, autoInt)
    fmt.Printf("Float types: %.2f, %.6f\n", precision, doublePrecision)
    fmt.Printf("String: %s, Rune: %c, Byte: %c\n", text, char, byteVal)
    fmt.Printf("Boolean: %t\n", isReady)
}
```

---

## 2. ν•¨μ μ •μ

### π”§ κΈ°λ³Έ ν•¨μ λ¬Έλ²•

```go
// κΈ°λ³Έ ν•¨μ ν•νƒ
func functionName(parameter1 type1, parameter2 type2) returnType {
    // ν•¨μ λ³Έλ¬Έ
    return value
}
```

### π’« λ‹¤μ–‘ν• ν•¨μ μμ 

#### 1. **λ§¤κ°λ³€μμ™€ λ°ν™κ°’μ΄ μλ” ν•¨μ**
```go
// λ‘ μλ¥Ό λ”ν•λ” ν•¨μ
func add(a int, b int) int {
    return a + b
}

// κ°™μ€ νƒ€μ… λ§¤κ°λ³€μλ” μ¶•μ•½ κ°€λ¥
func multiply(a, b int) int {
    return a * b
}

// λ¬Έμμ—΄ μ΅°μ‘ ν•¨μ
func greet(name string) string {
    return "Hello, " + name + "!"
}

func basicFunctions() {
    result1 := add(10, 20)
    result2 := multiply(5, 6)
    message := greet("Gopher")
    
    fmt.Printf("10 + 20 = %d\n", result1)
    fmt.Printf("5 Γ— 6 = %d\n", result2)
    fmt.Printf("%s\n", message)
}
```

#### 2. **λ‹¤μ¤‘ λ°ν™κ°’ (Goμ νΉμ§•!)**
```go
// λ‚λ—μ…κ³Ό λ‚λ¨Έμ§€λ¥Ό λ™μ‹μ— λ°ν™
func divideAndMod(a, b int) (int, int) {
    quotient := a / b
    remainder := a % b
    return quotient, remainder
}

// μ—λ¬μ™€ ν•¨κ» λ°ν™ (μΌλ°μ μΈ ν¨ν„΄)
func divide(a, b int) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return float64(a) / float64(b), nil
}

// μ΄λ¦„μλ” λ°ν™κ°’ (named return values)
func getCircleStats(radius float64) (area, circumference float64) {
    area = 3.14159 * radius * radius
    circumference = 2 * 3.14159 * radius
    return // μλ™μΌλ΅ area, circumference λ°ν™
}

func multipleReturns() {
    // λ‹¤μ¤‘ λ°ν™κ°’ λ°›κΈ°
    quotient, remainder := divideAndMod(17, 5)
    fmt.Printf("17 Γ· 5 = %d remainder %d\n", quotient, remainder)
    
    // μ—λ¬ μ²λ¦¬ ν¨ν„΄
    result, err := divide(10, 2)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Printf("10 Γ· 2 = %.2f\n", result)
    }
    
    // μ΄λ¦„μλ” λ°ν™κ°’
    area, circum := getCircleStats(5.0)
    fmt.Printf("Circle (r=5): Area=%.2f, Circumference=%.2f\n", area, circum)
}
```

#### 3. **κ°€λ³€ μΈμ ν•¨μ (Variadic Functions)**
```go
// κ°€λ³€ κ°μμ μ •μλ¥Ό λ°›μ•„μ„ ν•©κ³„ κ³„μ‚°
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// κ°€λ³€ μΈμ + λ‹¤λ¥Έ λ§¤κ°λ³€μ
func formatMessage(prefix string, messages ...string) string {
    result := prefix + ": "
    for i, msg := range messages {
        if i > 0 {
            result += ", "
        }
        result += msg
    }
    return result
}

func variadicFunctions() {
    // λ‹¤μ–‘ν• κ°μμ μΈμ μ „λ‹¬
    fmt.Printf("Sum of 1,2,3: %d\n", sum(1, 2, 3))
    fmt.Printf("Sum of 1,2,3,4,5: %d\n", sum(1, 2, 3, 4, 5))
    
    // μ¬λΌμ΄μ¤λ¥Ό κ°€λ³€ μΈμλ΅ μ „λ‹¬
    numbers := []int{10, 20, 30}
    fmt.Printf("Sum of slice: %d\n", sum(numbers...))
    
    // λ©”μ‹μ§€ ν¬λ§·ν…
    message := formatMessage("Alert", "Server down", "Database error", "High CPU")
    fmt.Println(message)
}
```

#### 4. **ν•¨μλ„ κ°’μ΄λ‹¤! (First-class functions)**
```go
// ν•¨μ νƒ€μ… μ •μ
type Operation func(int, int) int

// ν•¨μλ¥Ό λ§¤κ°λ³€μλ΅ λ°›λ” ν•¨μ
func calculate(a, b int, op Operation) int {
    return op(a, b)
}

// ν•¨μλ¥Ό λ°ν™ν•λ” ν•¨μ
func getOperation(operator string) Operation {
    switch operator {
    case "+":
        return add
    case "*":
        return multiply
    default:
        return func(a, b int) int { return 0 }
    }
}

func functionsAsValues() {
    // ν•¨μλ¥Ό λ³€μμ— ν• λ‹Ή
    var myFunc Operation = add
    result := myFunc(10, 20)
    fmt.Printf("Function variable: %d\n", result)
    
    // ν•¨μλ¥Ό λ§¤κ°λ³€μλ΅ μ „λ‹¬
    result2 := calculate(15, 3, multiply)
    fmt.Printf("Function parameter: %d\n", result2)
    
    // μµλ… ν•¨μ μ‚¬μ©
    subtract := func(a, b int) int {
        return a - b
    }
    result3 := calculate(20, 8, subtract)
    fmt.Printf("Anonymous function: %d\n", result3)
    
    // ν•¨μλ¥Ό λ°ν™λ°›μ•„ μ‚¬μ©
    addFunc := getOperation("+")
    result4 := addFunc(100, 200)
    fmt.Printf("Returned function: %d\n", result4)
}
```

---

## 3. μ—λ¬ μ²λ¦¬

### π¨ Goμ μ—λ¬ μ²λ¦¬ μ² ν•™

> [!note] Goμ μ—λ¬ μ²λ¦¬
> Goλ” μμ™Έ(exception) λ€μ‹  λ…μ‹μ μΈ μ—λ¬ λ°ν™μ„ μ‚¬μ©ν•©λ‹λ‹¤. μ—λ¬λ” κ°’μ΄λ©°, λ°λ“μ‹ ν™•μΈν•΄μ•Ό ν•©λ‹λ‹¤.

```go
import (
    "errors"
    "fmt"
    "strconv"
)

// κΈ°λ³Έ μ—λ¬ μ²λ¦¬ ν¨ν„΄
func parseAge(s string) (int, error) {
    age, err := strconv.Atoi(s)
    if err != nil {
        return 0, fmt.Errorf("invalid age format: %s", s)
    }
    
    if age < 0 || age > 150 {
        return 0, errors.New("age must be between 0 and 150")
    }
    
    return age, nil
}

// μ»¤μ¤ν…€ μ—λ¬ νƒ€μ…
type ValidationError struct {
    Field   string
    Value   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation error in field '%s': %s (value: %s)", 
        e.Field, e.Message, e.Value)
}

// μ»¤μ¤ν…€ μ—λ¬λ¥Ό λ°ν™ν•λ” ν•¨μ
func validateEmail(email string) error {
    if email == "" {
        return ValidationError{
            Field:   "email",
            Value:   email,
            Message: "email cannot be empty",
        }
    }
    
    if !strings.Contains(email, "@") {
        return ValidationError{
            Field:   "email",
            Value:   email,
            Message: "email must contain @ symbol",
        }
    }
    
    return nil
}

func errorHandling() {
    // κΈ°λ³Έ μ—λ¬ μ²λ¦¬
    age1, err := parseAge("25")
    if err != nil {
        fmt.Printf("Error parsing age: %v\n", err)
    } else {
        fmt.Printf("Valid age: %d\n", age1)
    }
    
    // μλ»λ μ…λ ¥ ν…μ¤νΈ
    age2, err := parseAge("abc")
    if err != nil {
        fmt.Printf("Error parsing age: %v\n", err)
    }
    
    // μ»¤μ¤ν…€ μ—λ¬ μ²λ¦¬
    if err := validateEmail(""); err != nil {
        fmt.Printf("Email validation error: %v\n", err)
        
        // μ—λ¬ νƒ€μ… ν™•μΈ
        if validErr, ok := err.(ValidationError); ok {
            fmt.Printf("Field: %s, Value: %s\n", validErr.Field, validErr.Value)
        }
    }
    
    if err := validateEmail("test@example.com"); err != nil {
        fmt.Printf("Email validation error: %v\n", err)
    } else {
        fmt.Println("Email is valid!")
    }
}
```

### π›΅οΈ μ—λ¬ μ²λ¦¬ λ² μ¤νΈ ν”„λ™ν‹°μ¤

```go
// 1. μ—λ¬ μ²΄ν¬ μƒλµν•μ§€ λ§κΈ°
func badExample() {
    data, _ := ioutil.ReadFile("config.json")  // λ‚μ μ: μ—λ¬ λ¬΄μ‹
    // νμΌμ΄ μ—†μ–΄λ„ ν”„λ΅κ·Έλ¨μ΄ κ³„μ† μ‹¤ν–‰λ¨
}

func goodExample() {
    data, err := ioutil.ReadFile("config.json")
    if err != nil {
        log.Fatalf("Failed to read config file: %v", err)
        return
    }
    // μ•μ „ν•κ² data μ‚¬μ©
}

// 2. μ—λ¬ λν•‘ (Go 1.13+)
func processFile(filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("failed to read file %s: %w", filename, err)
    }
    
    if err := validateData(data); err != nil {
        return fmt.Errorf("validation failed for file %s: %w", filename, err)
    }
    
    return nil
}

// 3. μ—λ¬ μ²΄μΈ ν™•μΈ
func checkErrorChain() {
    err := processFile("nonexistent.txt")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        
        // μ›λ³Έ μ—λ¬ ν™•μΈ
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("File does not exist")
        }
    }
}
```

---

## 4. ν¬μΈν„° κΈ°μ΄

### π― ν¬μΈν„°λ€?

> [!info] ν¬μΈν„°
> ν¬μΈν„°λ” λ©”λ¨λ¦¬ μ£Όμ†λ¥Ό μ €μ¥ν•λ” λ³€μμ…λ‹λ‹¤. Goμ ν¬μΈν„°λ” Cλ³΄λ‹¤ μ•μ „ν•λ©°, ν¬μΈν„° μ‚°μ  μ—°μ‚°μ€ μ§€μ›ν•μ§€ μ•μµλ‹λ‹¤.

```go
func pointerBasics() {
    // κΈ°λ³Έ λ³€μ
    x := 42
    
    // ν¬μΈν„° μ„ μ–Έ λ° μ΄κΈ°ν™”
    var p *int    // int νƒ€μ…μ„ κ°€λ¦¬ν‚¤λ” ν¬μΈν„°
    p = &x        // xμ μ£Όμ†λ¥Ό pμ— μ €μ¥
    
    fmt.Printf("xμ κ°’: %d\n", x)
    fmt.Printf("xμ μ£Όμ†: %p\n", &x)
    fmt.Printf("pμ κ°’ (μ£Όμ†): %p\n", p)
    fmt.Printf("pκ°€ κ°€λ¦¬ν‚¤λ” κ°’: %d\n", *p)  // μ—­μ°Έμ΅°
    
    // ν¬μΈν„°λ¥Ό ν†µν• κ°’ λ³€κ²½
    *p = 100
    fmt.Printf("ν¬μΈν„°λ΅ λ³€κ²½ ν›„ xμ κ°’: %d\n", x)
}
```

### π”„ ν•¨μμ™€ ν¬μΈν„°

```go
// κ°’μ— μν• νΈμ¶ (Call by Value)
func doubleValue(x int) int {
    x = x * 2
    return x  // μ›λ³Έμ€ λ³€κ²½λμ§€ μ•μ
}

// ν¬μΈν„°μ— μν• νΈμ¶ (Call by Pointer)
func doublePointer(x *int) {
    *x = *x * 2  // μ›λ³Έ κ°’μ΄ λ³€κ²½λ¨
}

// κµ¬μ΅°μ²΄μ™€ ν¬μΈν„°
type Person struct {
    Name string
    Age  int
}

func (p Person) growUpValue() {
    p.Age++  // λ³µμ‚¬λ³Έμ λ‚μ΄λ§ μ¦κ°€
}

func (p *Person) growUpPointer() {
    p.Age++  // μ›λ³Έμ λ‚μ΄κ°€ μ¦κ°€
}

func pointerFunctions() {
    // κ°’ μ „λ‹¬ vs ν¬μΈν„° μ „λ‹¬
    num := 10
    
    doubled := doubleValue(num)
    fmt.Printf("After doubleValue - num: %d, returned: %d\n", num, doubled)
    
    doublePointer(&num)
    fmt.Printf("After doublePointer - num: %d\n", num)
    
    // κµ¬μ΅°μ²΄μ™€ ν¬μΈν„°
    person := Person{Name: "Alice", Age: 25}
    
    person.growUpValue()
    fmt.Printf("After growUpValue: %+v\n", person)
    
    person.growUpPointer()
    fmt.Printf("After growUpPointer: %+v\n", person)
}
```

### π†• μƒλ΅μ΄ λ©”λ¨λ¦¬ ν• λ‹Ή

```go
func memoryAllocation() {
    // new() ν•¨μ: μμ μΌλ΅ μ΄κΈ°ν™”λ λ©”λ¨λ¦¬ ν• λ‹Ή
    p1 := new(int)        // *int νƒ€μ…, 0μΌλ΅ μ΄κΈ°ν™”
    *p1 = 42
    fmt.Printf("new()λ΅ ν• λ‹Ή: %d\n", *p1)
    
    // &λ¥Ό μ‚¬μ©ν• μ£Όμ† νλ“
    x := 100
    p2 := &x
    fmt.Printf("&λ΅ μ£Όμ† νλ“: %d\n", *p2)
    
    // make()λ” μ¬λΌμ΄μ¤, λ§µ, μ±„λ„μ©
    slice := make([]int, 5)  // κΈΈμ΄ 5μΈ int μ¬λΌμ΄μ¤
    slice[0] = 10
    fmt.Printf("make()λ΅ μ¬λΌμ΄μ¤: %v\n", slice)
}
```

---

## π― μ‹¤μµ μμ 

### π“ μ—°μµ λ¬Έμ  1: κ³„μ‚°κΈ° ν•¨μ

```go
package main

import (
    "fmt"
    "errors"
)

// μ‚¬μΉ™μ—°μ‚° κ³„μ‚°κΈ°
func calculator(a, b float64, operator string) (float64, error) {
    switch operator {
    case "+":
        return a + b, nil
    case "-":
        return a - b, nil
    case "*":
        return a * b, nil
    case "/":
        if b == 0 {
            return 0, errors.New("division by zero")
        }
        return a / b, nil
    default:
        return 0, fmt.Errorf("unknown operator: %s", operator)
    }
}

func calculatorTest() {
    operations := []struct {
        a, b     float64
        operator string
    }{
        {10, 5, "+"},
        {10, 5, "-"},
        {10, 5, "*"},
        {10, 5, "/"},
        {10, 0, "/"},  // μ—λ¬ μΌ€μ΄μ¤
        {10, 5, "%"},  // μ—λ¬ μΌ€μ΄μ¤
    }
    
    for _, op := range operations {
        result, err := calculator(op.a, op.b, op.operator)
        if err != nil {
            fmt.Printf("%.1f %s %.1f = Error: %v\n", 
                op.a, op.operator, op.b, err)
        } else {
            fmt.Printf("%.1f %s %.1f = %.2f\n", 
                op.a, op.operator, op.b, result)
        }
    }
}
```

### π“ μ—°μµ λ¬Έμ  2: λ¬Έμμ—΄ μ²λ¦¬ ν•¨μ

```go
import "strings"

// λ¬Έμμ—΄ ν†µκ³„ μ •λ³΄
type StringStats struct {
    Length    int
    Words     int
    Vowels    int
    Uppercase int
    Lowercase int
}

func analyzeString(text string) StringStats {
    stats := StringStats{
        Length: len(text),
        Words:  len(strings.Fields(text)),
    }
    
    vowels := "aeiouAEIOU"
    
    for _, char := range text {
        if strings.ContainsRune(vowels, char) {
            stats.Vowels++
        }
        
        if char >= 'A' && char <= 'Z' {
            stats.Uppercase++
        } else if char >= 'a' && char <= 'z' {
            stats.Lowercase++
        }
    }
    
    return stats
}

func stringAnalysisTest() {
    texts := []string{
        "Hello, Go!",
        "The Quick Brown Fox Jumps Over The Lazy Dog",
        "golang is AWESOME",
    }
    
    for _, text := range texts {
        stats := analyzeString(text)
        fmt.Printf("\nText: %s\n", text)
        fmt.Printf("  Length: %d characters\n", stats.Length)
        fmt.Printf("  Words: %d\n", stats.Words)
        fmt.Printf("  Vowels: %d\n", stats.Vowels)
        fmt.Printf("  Uppercase: %d\n", stats.Uppercase)
        fmt.Printf("  Lowercase: %d\n", stats.Lowercase)
    }
}
```

### π“ μ—°μµ λ¬Έμ  3: ν¬μΈν„°λ¥Ό μ‚¬μ©ν• μ¤μ™‘ ν•¨μ

```go
// λ‘ κ°’μ„ κµν™ν•λ” ν•¨μ
func swap(a, b *int) {
    temp := *a
    *a = *b
    *b = temp
}

// λ¬Έμμ—΄ μ¤μ™‘
func swapStrings(s1, s2 *string) {
    *s1, *s2 = *s2, *s1  // Goμ λ‹¤μ¤‘ ν• λ‹Ή μ‚¬μ©
}

func swapTest() {
    // μ •μ μ¤μ™‘
    x, y := 10, 20
    fmt.Printf("Before swap: x=%d, y=%d\n", x, y)
    swap(&x, &y)
    fmt.Printf("After swap: x=%d, y=%d\n", x, y)
    
    // λ¬Έμμ—΄ μ¤μ™‘
    name1, name2 := "Alice", "Bob"
    fmt.Printf("Before swap: name1=%s, name2=%s\n", name1, name2)
    swapStrings(&name1, &name2)
    fmt.Printf("After swap: name1=%s, name2=%s\n", name1, name2)
}
```

---

## β… μ²΄ν¬λ¦¬μ¤νΈ

### λ³€μμ™€ νƒ€μ…
- [ ] 4κ°€μ§€ λ³€μ μ„ μ–Έ λ°©λ²• μ΄ν•΄
- [ ] κΈ°λ³Έ λ°μ΄ν„° νƒ€μ… νμ•…
- [ ] νƒ€μ… μ¶”λ΅  μ›λ¦¬ μ΄ν•΄
- [ ] Zero values κ°λ… νμ•…

### ν•¨μ
- [ ] κΈ°λ³Έ ν•¨μ λ¬Έλ²• μ΄ν•΄
- [ ] λ‹¤μ¤‘ λ°ν™κ°’ ν™μ©λ²•
- [ ] κ°€λ³€ μΈμ ν•¨μ μ‚¬μ©λ²•
- [ ] ν•¨μλ¥Ό κ°’μΌλ΅ λ‹¤λ£¨κΈ°

### μ—λ¬ μ²λ¦¬
- [ ] Goμ μ—λ¬ μ²λ¦¬ μ² ν•™ μ΄ν•΄
- [ ] κΈ°λ³Έ μ—λ¬ μ²λ¦¬ ν¨ν„΄
- [ ] μ»¤μ¤ν…€ μ—λ¬ νƒ€μ… μƒμ„±
- [ ] μ—λ¬ λν•‘κ³Ό μ²΄μΈ

### ν¬μΈν„°
- [ ] ν¬μΈν„° κΈ°λ³Έ κ°λ…
- [ ] κ°’ μ „λ‹¬ vs ν¬μΈν„° μ „λ‹¬
- [ ] λ©”λ¨λ¦¬ ν• λ‹Ή λ°©λ²•
- [ ] ν¬μΈν„° μ•μ „μ„± μ΄ν•΄

---

> [!tip] λ‹¤μ λ‹¨κ³„
> κΈ°λ³Έ λ¬Έλ²•μ„ μµν”λ‹¤λ©΄ [[03-GO-κµ¬μ΅°μ²΄-μΈν„°νμ΄μ¤|GO κµ¬μ΅°μ²΄μ™€ μΈν„°νμ΄μ¤]]λ΅ λ„μ–΄κ°€μ„Έμ”!