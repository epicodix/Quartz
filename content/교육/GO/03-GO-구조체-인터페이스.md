---
title: GO êµ¬ì¡°ì²´ì™€ ì¸í„°í˜ì´ìŠ¤
tags:
  - golang
  - struct
  - interface
  - methods
  - oop
aliases:
  - Go-Struct
  - Go-Interface
  - GO-ê°ì²´ì§€í–¥
date: 2025-11-26
category: êµìœ¡/GO/ì¤‘ê¸‰
status: ì™„ì„±
priority: ë†’ìŒ
---

# ğŸ—ï¸ GO êµ¬ì¡°ì²´ì™€ ì¸í„°í˜ì´ìŠ¤

## ğŸ“‹ ëª©ì°¨
- [[#1. êµ¬ì¡°ì²´ ê¸°ì´ˆ|1. êµ¬ì¡°ì²´ ê¸°ì´ˆ]]
- [[#2. ë©”ì„œë“œ|2. ë©”ì„œë“œ]]
- [[#3. ì¸í„°í˜ì´ìŠ¤|3. ì¸í„°í˜ì´ìŠ¤]]
- [[#4. ì„ë² ë”©ê³¼ ì»´í¬ì§€ì…˜|4. ì„ë² ë”©ê³¼ ì»´í¬ì§€ì…˜]]
- [[#ğŸ¯ ì‹¤ìŠµ ì˜ˆì œ|ì‹¤ìŠµ ì˜ˆì œ]]

---

## 1. êµ¬ì¡°ì²´ ê¸°ì´ˆ

### ğŸ“¦ êµ¬ì¡°ì²´ ì •ì˜ì™€ ìƒì„±

> [!note] êµ¬ì¡°ì²´ë€?
> êµ¬ì¡°ì²´ëŠ” ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì˜ ë°ì´í„°ë¥¼ í•˜ë‚˜ë¡œ ë¬¶ëŠ” ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì…ë‹ˆë‹¤. Goì˜ ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì˜ ê¸°ì´ˆê°€ ë©ë‹ˆë‹¤.

```go
package main

import (
    "fmt"
    "time"
)

// ê¸°ë³¸ êµ¬ì¡°ì²´ ì •ì˜
type Person struct {
    Name    string
    Age     int
    Email   string
    IsActive bool
}

// êµ¬ì¡°ì²´ í•„ë“œì— íƒœê·¸ ì¶”ê°€ (JSON, ê²€ì¦ ë“±ì— ì‚¬ìš©)
type User struct {
    ID       int    `json:"id" validate:"required"`
    Username string `json:"username" validate:"required,min=3"`
    Password string `json:"-"`                    // JSONì—ì„œ ì œì™¸
    Email    string `json:"email" validate:"email"`
    CreatedAt time.Time `json:"created_at"`
}

// ì¤‘ì²© êµ¬ì¡°ì²´
type Address struct {
    Street   string
    City     string
    ZipCode  string
    Country  string
}

type Employee struct {
    Person                    // ì„ë² ë”© (ìƒì†ê³¼ ìœ ì‚¬)
    ID       int             // ì§ì› ID
    Position string          // ì§ì±…
    Salary   float64         // ê¸‰ì—¬
    Address  Address         // ì£¼ì†Œ (ì»´í¬ì§€ì…˜)
    Manager  *Employee       // ë§¤ë‹ˆì € (ìê¸° ì°¸ì¡°)
}

func structBasics() {
    // 1. êµ¬ì¡°ì²´ ìƒì„± ë°©ë²•ë“¤
    
    // í•„ë“œë³„ ì´ˆê¸°í™”
    person1 := Person{
        Name:     "Alice",
        Age:      30,
        Email:    "alice@example.com",
        IsActive: true,
    }
    
    // ìˆœì„œëŒ€ë¡œ ì´ˆê¸°í™”
    person2 := Person{"Bob", 25, "bob@example.com", false}
    
    // ë¹ˆ êµ¬ì¡°ì²´ ìƒì„± í›„ í•„ë“œ ì„¤ì •
    var person3 Person
    person3.Name = "Charlie"
    person3.Age = 35
    
    // new()ë¥¼ ì‚¬ìš©í•œ í¬ì¸í„° ìƒì„±
    person4 := new(Person)
    person4.Name = "Diana"
    person4.Age = 28
    
    fmt.Printf("Person1: %+v\n", person1)
    fmt.Printf("Person2: %+v\n", person2)
    fmt.Printf("Person3: %+v\n", person3)
    fmt.Printf("Person4: %+v\n", *person4)
}
```

### ğŸ”„ êµ¬ì¡°ì²´ ì¡°ì‘

```go
func structOperations() {
    // êµ¬ì¡°ì²´ ìƒì„±
    user := User{
        ID:        1,
        Username:  "gopher",
        Email:     "gopher@golang.org",
        CreatedAt: time.Now(),
    }
    
    // í•„ë“œ ì ‘ê·¼ ë° ìˆ˜ì •
    fmt.Printf("Original user: %+v\n", user)
    
    user.Username = "super_gopher"
    user.Email = "super_gopher@golang.org"
    
    fmt.Printf("Modified user: %+v\n", user)
    
    // êµ¬ì¡°ì²´ ë³µì‚¬ (ê°’ ë³µì‚¬)
    userCopy := user
    userCopy.Username = "copy_gopher"
    
    fmt.Printf("Original after copy: %+v\n", user)
    fmt.Printf("Copy: %+v\n", userCopy)
    
    // êµ¬ì¡°ì²´ í¬ì¸í„°
    userPtr := &user
    userPtr.Email = "ptr_gopher@golang.org"
    
    fmt.Printf("After pointer modification: %+v\n", user)
}
```

### ğŸ¢ ë³µì¡í•œ êµ¬ì¡°ì²´ ì˜ˆì œ

```go
func complexStructs() {
    // ë§¤ë‹ˆì € ìƒì„±
    manager := &Employee{
        Person: Person{
            Name:     "John Manager",
            Age:      45,
            Email:    "john.manager@company.com",
            IsActive: true,
        },
        ID:       101,
        Position: "Engineering Manager",
        Salary:   120000.0,
        Address: Address{
            Street:  "123 Manager St",
            City:    "San Francisco",
            ZipCode: "94105",
            Country: "USA",
        },
        Manager: nil, // ìµœê³  ê´€ë¦¬ì
    }
    
    // ì§ì› ìƒì„±
    employee := Employee{
        Person: Person{
            Name:     "Jane Developer",
            Age:      28,
            Email:    "jane.dev@company.com",
            IsActive: true,
        },
        ID:       201,
        Position: "Software Engineer",
        Salary:   85000.0,
        Address: Address{
            Street:  "456 Dev Ave",
            City:    "San Francisco", 
            ZipCode: "94107",
            Country: "USA",
        },
        Manager: manager, // ë§¤ë‹ˆì € í• ë‹¹
    }
    
    // ì •ë³´ ì¶œë ¥
    fmt.Printf("Employee: %s\n", employee.Name)  // ì„ë² ë”©ëœ í•„ë“œ ì§ì ‘ ì ‘ê·¼
    fmt.Printf("Position: %s\n", employee.Position)
    fmt.Printf("Manager: %s\n", employee.Manager.Name)
    fmt.Printf("Address: %s, %s\n", employee.Address.City, employee.Address.Country)
}
```

---

## 2. ë©”ì„œë“œ

### ğŸ¯ ë©”ì„œë“œ ì •ì˜

> [!info] ë©”ì„œë“œë€?
> ë©”ì„œë“œëŠ” íŠ¹ì • íƒ€ì…ì— ì—°ê²°ëœ í•¨ìˆ˜ì…ë‹ˆë‹¤. ë¦¬ì‹œë²„(receiver)ë¥¼ í†µí•´ êµ¬ì¡°ì²´ì™€ ì—°ê²°ë©ë‹ˆë‹¤.

```go
import (
    "fmt"
    "math"
)

type Circle struct {
    X, Y   float64  // ì¤‘ì‹¬ ì¢Œí‘œ
    Radius float64  // ë°˜ì§€ë¦„
}

type Rectangle struct {
    Width, Height float64
}

// ê°’ ë¦¬ì‹œë²„ ë©”ì„œë“œ
func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Circumference() float64 {
    return 2 * math.Pi * c.Radius
}

// í¬ì¸í„° ë¦¬ì‹œë²„ ë©”ì„œë“œ (ì›ë³¸ ìˆ˜ì • ê°€ëŠ¥)
func (c *Circle) Scale(factor float64) {
    c.Radius *= factor
}

func (c *Circle) MoveTo(x, y float64) {
    c.X = x
    c.Y = y
}

// String() ë©”ì„œë“œ (fmt íŒ¨í‚¤ì§€ê°€ ìë™ìœ¼ë¡œ í˜¸ì¶œ)
func (c Circle) String() string {
    return fmt.Sprintf("Circle(center: %.1f,%.1f, radius: %.1f)", 
        c.X, c.Y, c.Radius)
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

func methodBasics() {
    circle := Circle{X: 0, Y: 0, Radius: 5}
    
    // ê°’ ë¦¬ì‹œë²„ ë©”ì„œë“œ í˜¸ì¶œ
    fmt.Printf("Circle area: %.2f\n", circle.Area())
    fmt.Printf("Circle circumference: %.2f\n", circle.Circumference())
    
    // í¬ì¸í„° ë¦¬ì‹œë²„ ë©”ì„œë“œ í˜¸ì¶œ
    fmt.Printf("Before scaling: %v\n", circle)
    circle.Scale(2.0)  // Goê°€ ìë™ìœ¼ë¡œ &circle.Scale(2.0)ë¡œ ë³€í™˜
    fmt.Printf("After scaling: %v\n", circle)
    
    circle.MoveTo(10, 10)
    fmt.Printf("After moving: %v\n", circle)
    
    // Rectangle
    rect := Rectangle{Width: 10, Height: 20}
    fmt.Printf("Rectangle area: %.2f\n", rect.Area())
    fmt.Printf("Rectangle perimeter: %.2f\n", rect.Perimeter())
}
```

### ğŸ”„ ê°’ ë¦¬ì‹œë²„ vs í¬ì¸í„° ë¦¬ì‹œë²„

```go
type Counter struct {
    value int
}

// ê°’ ë¦¬ì‹œë²„ - ë³µì‚¬ë³¸ì—ì„œ ì‘ì—… (ì›ë³¸ ë³€ê²½ ì•ˆë¨)
func (c Counter) IncrementValue() {
    c.value++  // ë³µì‚¬ë³¸ë§Œ ë³€ê²½ë¨
}

// í¬ì¸í„° ë¦¬ì‹œë²„ - ì›ë³¸ì—ì„œ ì‘ì—… (ì›ë³¸ ë³€ê²½ë¨)
func (c *Counter) IncrementPointer() {
    c.value++  // ì›ë³¸ì´ ë³€ê²½ë¨
}

func (c Counter) GetValue() int {
    return c.value
}

// í¬ì¸í„° ë¦¬ì‹œë²„ë¡œ String êµ¬í˜„
func (c *Counter) String() string {
    return fmt.Sprintf("Counter{value: %d}", c.value)
}

func receiverTypes() {
    counter := Counter{value: 0}
    
    fmt.Printf("Initial: %v\n", counter)
    
    // ê°’ ë¦¬ì‹œë²„ í˜¸ì¶œ - ì›ë³¸ ë³€ê²½ ì•ˆë¨
    counter.IncrementValue()
    fmt.Printf("After IncrementValue: %v\n", counter)
    
    // í¬ì¸í„° ë¦¬ì‹œë²„ í˜¸ì¶œ - ì›ë³¸ ë³€ê²½ë¨
    counter.IncrementPointer()
    fmt.Printf("After IncrementPointer: %v\n", counter)
    
    // í¬ì¸í„°ë¥¼ í†µí•´ì„œë„ í˜¸ì¶œ ê°€ëŠ¥
    counterPtr := &counter
    counterPtr.IncrementPointer()
    fmt.Printf("After pointer increment: %v\n", counter)
}
```

---

## 3. ì¸í„°í˜ì´ìŠ¤

### ğŸ­ ì¸í„°í˜ì´ìŠ¤ ê¸°ì´ˆ

> [!tip] Goì˜ ì¸í„°í˜ì´ìŠ¤
> Goì˜ ì¸í„°í˜ì´ìŠ¤ëŠ” ì•”ì‹œì ì…ë‹ˆë‹¤. ëª…ì‹œì ìœ¼ë¡œ êµ¬í˜„ì„ ì„ ì–¸í•  í•„ìš” ì—†ì´, ë©”ì„œë“œë§Œ êµ¬í˜„í•˜ë©´ ìë™ìœ¼ë¡œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§Œì¡±í•©ë‹ˆë‹¤.

```go
// Shape ì¸í„°í˜ì´ìŠ¤ ì •ì˜
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Drawable ì¸í„°í˜ì´ìŠ¤
type Drawable interface {
    Draw() string
}

// ë³µí•© ì¸í„°í˜ì´ìŠ¤ (ì¸í„°í˜ì´ìŠ¤ ì„ë² ë”©)
type DrawableShape interface {
    Shape      // Shape ì¸í„°í˜ì´ìŠ¤ ì„ë² ë”©
    Drawable   // Drawable ì¸í„°í˜ì´ìŠ¤ ì„ë² ë”©
}

// Circleì˜ Drawable ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
func (c Circle) Perimeter() float64 {
    return c.Circumference()  // ê¸°ì¡´ ë©”ì„œë“œ ì¬ì‚¬ìš©
}

func (c Circle) Draw() string {
    return fmt.Sprintf("Drawing a circle with radius %.1f at (%.1f, %.1f)", 
        c.Radius, c.X, c.Y)
}

// Rectangleì˜ Drawable ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
func (r Rectangle) Draw() string {
    return fmt.Sprintf("Drawing a rectangle %.1fx%.1f", r.Width, r.Height)
}

// Triangle ìƒˆë¡œìš´ ë„í˜•
type Triangle struct {
    A, B, C float64  // ì„¸ ë³€ì˜ ê¸¸ì´
}

func (t Triangle) Area() float64 {
    s := (t.A + t.B + t.C) / 2  // ë°˜ë‘˜ë ˆ
    return math.Sqrt(s * (s - t.A) * (s - t.B) * (s - t.C))  // í—¤ë¡ ì˜ ê³µì‹
}

func (t Triangle) Perimeter() float64 {
    return t.A + t.B + t.C
}

func (t Triangle) Draw() string {
    return fmt.Sprintf("Drawing a triangle with sides %.1f, %.1f, %.1f", 
        t.A, t.B, t.C)
}

func interfaceBasics() {
    // ë‹¤ì–‘í•œ ë„í˜• ìƒì„±
    shapes := []Shape{
        Circle{Radius: 5},
        Rectangle{Width: 10, Height: 20},
        Triangle{A: 3, B: 4, C: 5},
    }
    
    // ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•œ í´ë¦¬ëª¨í”¼ì¦˜
    for i, shape := range shapes {
        fmt.Printf("Shape %d:\n", i+1)
        fmt.Printf("  Area: %.2f\n", shape.Area())
        fmt.Printf("  Perimeter: %.2f\n", shape.Perimeter())
        
        // íƒ€ì… assertionì„ í†µí•œ êµ¬ì²´ íƒ€ì… í™•ì¸
        switch s := shape.(type) {
        case Circle:
            fmt.Printf("  Type: Circle (radius: %.1f)\n", s.Radius)
        case Rectangle:
            fmt.Printf("  Type: Rectangle (%.1fx%.1f)\n", s.Width, s.Height)
        case Triangle:
            fmt.Printf("  Type: Triangle (sides: %.1f, %.1f, %.1f)\n", s.A, s.B, s.C)
        }
        
        // Drawable ì¸í„°í˜ì´ìŠ¤ ì²´í¬
        if drawable, ok := shape.(Drawable); ok {
            fmt.Printf("  %s\n", drawable.Draw())
        }
        
        fmt.Println()
    }
}
```

### ğŸ” ì¸í„°í˜ì´ìŠ¤ ê³ ê¸‰ í™œìš©

```go
import (
    "io"
    "strings"
    "encoding/json"
)

// ë¹ˆ ì¸í„°í˜ì´ìŠ¤ (ëª¨ë“  íƒ€ì…ì„ ë‹´ì„ ìˆ˜ ìˆìŒ)
func handleAny(value interface{}) {
    fmt.Printf("Value: %v, Type: %T\n", value, value)
    
    // íƒ€ì… ìŠ¤ìœ„ì¹˜
    switch v := value.(type) {
    case int:
        fmt.Printf("  Integer: %d\n", v)
    case string:
        fmt.Printf("  String: %s\n", v)
    case []int:
        fmt.Printf("  Int slice: %v\n", v)
    case Shape:
        fmt.Printf("  Shape with area: %.2f\n", v.Area())
    default:
        fmt.Printf("  Unknown type: %T\n", v)
    }
}

// ì¸í„°í˜ì´ìŠ¤ ì¡°í•©
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}

// io.ReadWriterëŠ” Readerì™€ Writerë¥¼ ëª¨ë‘ êµ¬í˜„
type ReadWriter interface {
    Reader
    Writer
}

// ì»¤ìŠ¤í…€ Writer êµ¬í˜„
type StringWriter struct {
    data strings.Builder
}

func (sw *StringWriter) Write(p []byte) (n int, err error) {
    return sw.data.Write(p)
}

func (sw *StringWriter) String() string {
    return sw.data.String()
}

func interfaceAdvanced() {
    // ë¹ˆ ì¸í„°í˜ì´ìŠ¤ ì‚¬ìš©
    values := []interface{}{
        42,
        "Hello",
        []int{1, 2, 3},
        Circle{Radius: 3},
        Rectangle{Width: 5, Height: 10},
    }
    
    for _, val := range values {
        handleAny(val)
        fmt.Println()
    }
    
    // Writer ì¸í„°í˜ì´ìŠ¤ ì‚¬ìš©
    var writer StringWriter
    
    // io.WriteStringì€ Writer ì¸í„°í˜ì´ìŠ¤ë¥¼ ë°›ìŒ
    io.WriteString(&writer, "Hello, ")
    io.WriteString(&writer, "Go Interface!")
    
    fmt.Printf("Writer result: %s\n", writer.String())
}
```

### ğŸ¯ ì¸í„°í˜ì´ìŠ¤ ì‹¤ì „ íŒ¨í„´

```go
// Strategy íŒ¨í„´
type PaymentProcessor interface {
    ProcessPayment(amount float64) error
    GetFee(amount float64) float64
}

type CreditCardProcessor struct {
    CardNumber string
}

func (cc CreditCardProcessor) ProcessPayment(amount float64) error {
    fmt.Printf("Processing credit card payment: $%.2f\n", amount)
    return nil
}

func (cc CreditCardProcessor) GetFee(amount float64) float64 {
    return amount * 0.03  // 3% ìˆ˜ìˆ˜ë£Œ
}

type PayPalProcessor struct {
    Email string
}

func (pp PayPalProcessor) ProcessPayment(amount float64) error {
    fmt.Printf("Processing PayPal payment: $%.2f\n", amount)
    return nil
}

func (pp PayPalProcessor) GetFee(amount float64) float64 {
    return amount * 0.025  // 2.5% ìˆ˜ìˆ˜ë£Œ
}

// ê²°ì œ ì„œë¹„ìŠ¤
type PaymentService struct {
    processor PaymentProcessor
}

func NewPaymentService(processor PaymentProcessor) *PaymentService {
    return &PaymentService{processor: processor}
}

func (ps *PaymentService) ProcessOrder(amount float64) error {
    fee := ps.processor.GetFee(amount)
    totalAmount := amount + fee
    
    fmt.Printf("Order amount: $%.2f, Fee: $%.2f, Total: $%.2f\n", 
        amount, fee, totalAmount)
    
    return ps.processor.ProcessPayment(totalAmount)
}

func strategyPattern() {
    // ì‹ ìš©ì¹´ë“œ ê²°ì œ
    ccProcessor := CreditCardProcessor{CardNumber: "**** **** **** 1234"}
    ccService := NewPaymentService(ccProcessor)
    ccService.ProcessOrder(100.00)
    
    fmt.Println()
    
    // PayPal ê²°ì œ
    ppProcessor := PayPalProcessor{Email: "user@example.com"}
    ppService := NewPaymentService(ppProcessor)
    ppService.ProcessOrder(100.00)
}
```

---

## 4. ì„ë² ë”©ê³¼ ì»´í¬ì§€ì…˜

### ğŸ§© êµ¬ì¡°ì²´ ì„ë² ë”©

> [!note] ì„ë² ë”©
> GoëŠ” ìƒì†ì„ ì§€ì›í•˜ì§€ ì•Šì§€ë§Œ, êµ¬ì¡°ì²´ ì„ë² ë”©ì„ í†µí•´ ìœ ì‚¬í•œ íš¨ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```go
// ê¸°ë³¸ ì—”í‹°í‹°
type BaseEntity struct {
    ID        int
    CreatedAt time.Time
    UpdatedAt time.Time
}

func (be *BaseEntity) SetID(id int) {
    be.ID = id
}

func (be *BaseEntity) GetID() int {
    return be.ID
}

func (be *BaseEntity) Touch() {
    be.UpdatedAt = time.Now()
}

// ì‚¬ìš©ì ì—”í‹°í‹° (BaseEntity ì„ë² ë”©)
type User struct {
    BaseEntity        // ì„ë² ë”© (ìµëª… í•„ë“œ)
    Username   string
    Email      string
    IsActive   bool
}

func (u *User) Activate() {
    u.IsActive = true
    u.Touch()  // ì„ë² ë”©ëœ ë©”ì„œë“œ í˜¸ì¶œ
}

func (u *User) Deactivate() {
    u.IsActive = false
    u.Touch()
}

// ì œí’ˆ ì—”í‹°í‹° (BaseEntity ì„ë² ë”©)
type Product struct {
    BaseEntity
    Name        string
    Price       float64
    InStock     bool
    Description string
}

func (p *Product) UpdatePrice(newPrice float64) {
    p.Price = newPrice
    p.Touch()  // ì„ë² ë”©ëœ ë©”ì„œë“œ í˜¸ì¶œ
}

func embeddingExample() {
    // ì‚¬ìš©ì ìƒì„±
    user := User{
        BaseEntity: BaseEntity{
            ID:        1,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        },
        Username: "gopher",
        Email:    "gopher@example.com",
        IsActive: false,
    }
    
    fmt.Printf("User before activation: %+v\n", user)
    
    // ì„ë² ë”©ëœ ë©”ì„œë“œì™€ ì¶”ê°€ëœ ë©”ì„œë“œ ì‚¬ìš©
    user.Activate()
    fmt.Printf("User after activation: %+v\n", user)
    
    // ì„ë² ë”©ëœ í•„ë“œ ì§ì ‘ ì ‘ê·¼
    fmt.Printf("User ID: %d\n", user.ID)  // user.BaseEntity.IDì™€ ê°™ìŒ
    fmt.Printf("User ID (method): %d\n", user.GetID())
    
    // ì œí’ˆ ìƒì„±
    product := Product{
        BaseEntity: BaseEntity{
            ID:        101,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        },
        Name:        "Go Programming Book",
        Price:       29.99,
        InStock:     true,
        Description: "Learn Go programming",
    }
    
    fmt.Printf("\nProduct before price update: %+v\n", product)
    product.UpdatePrice(24.99)
    fmt.Printf("Product after price update: %+v\n", product)
}
```

### ğŸ”„ ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ

```go
// ë¡œê¹… ê¸°ëŠ¥ì´ ìˆëŠ” ê¸°ë³¸ êµ¬ì¡°ì²´
type Logger struct {
    Name string
}

func (l Logger) Log(message string) {
    fmt.Printf("[%s] %s\n", l.Name, message)
}

func (l Logger) Info(message string) {
    l.Log("INFO: " + message)
}

// ë°ì´í„°ë² ì´ìŠ¤ ë¡œê±° (Logger ì„ë² ë”©)
type DatabaseLogger struct {
    Logger
    Connection string
}

// Log ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ
func (dl DatabaseLogger) Log(message string) {
    fmt.Printf("[DB:%s] [%s] %s\n", dl.Connection, dl.Name, message)
}

// íŒŒì¼ ë¡œê±° (Logger ì„ë² ë”©)
type FileLogger struct {
    Logger
    FilePath string
}

// Log ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ
func (fl FileLogger) Log(message string) {
    fmt.Printf("[FILE:%s] [%s] %s\n", fl.FilePath, fl.Name, message)
}

func methodOverride() {
    // ê¸°ë³¸ ë¡œê±°
    basicLogger := Logger{Name: "BasicLogger"}
    basicLogger.Log("Basic log message")
    basicLogger.Info("Basic info message")
    
    fmt.Println()
    
    // ë°ì´í„°ë² ì´ìŠ¤ ë¡œê±°
    dbLogger := DatabaseLogger{
        Logger:     Logger{Name: "DBLogger"},
        Connection: "postgresql://localhost:5432",
    }
    dbLogger.Log("Database log message")      // ì˜¤ë²„ë¼ì´ë“œëœ ë©”ì„œë“œ
    dbLogger.Info("Database info message")    // ì„ë² ë”©ëœ ë©”ì„œë“œê°€ ì˜¤ë²„ë¼ì´ë“œëœ Log í˜¸ì¶œ
    
    fmt.Println()
    
    // íŒŒì¼ ë¡œê±°
    fileLogger := FileLogger{
        Logger:   Logger{Name: "FileLogger"},
        FilePath: "/var/log/app.log",
    }
    fileLogger.Log("File log message")        // ì˜¤ë²„ë¼ì´ë“œëœ ë©”ì„œë“œ
    fileLogger.Info("File info message")      // ì„ë² ë”©ëœ ë©”ì„œë“œê°€ ì˜¤ë²„ë¼ì´ë“œëœ Log í˜¸ì¶œ
}
```

---

## ğŸ¯ ì‹¤ìŠµ ì˜ˆì œ

### ğŸ“ ì—°ìŠµ ë¬¸ì œ 1: ì€í–‰ ê³„ì¢Œ ì‹œìŠ¤í…œ

```go
package main

import (
    "fmt"
    "errors"
    "time"
)

// ê³„ì¢Œ ì¸í„°í˜ì´ìŠ¤
type Account interface {
    Deposit(amount float64) error
    Withdraw(amount float64) error
    GetBalance() float64
    GetAccountInfo() string
}

// ê¸°ë³¸ ê³„ì¢Œ
type BaseAccount struct {
    AccountNumber string
    Owner         string
    Balance       float64
    CreatedAt     time.Time
}

func (ba *BaseAccount) Deposit(amount float64) error {
    if amount <= 0 {
        return errors.New("deposit amount must be positive")
    }
    ba.Balance += amount
    return nil
}

func (ba *BaseAccount) GetBalance() float64 {
    return ba.Balance
}

func (ba *BaseAccount) GetAccountInfo() string {
    return fmt.Sprintf("Account: %s, Owner: %s, Balance: $%.2f", 
        ba.AccountNumber, ba.Owner, ba.Balance)
}

// ì €ì¶• ê³„ì¢Œ (BaseAccount ì„ë² ë”©)
type SavingsAccount struct {
    BaseAccount
    InterestRate float64
}

func (sa *SavingsAccount) Withdraw(amount float64) error {
    if amount <= 0 {
        return errors.New("withdrawal amount must be positive")
    }
    if sa.Balance < amount {
        return errors.New("insufficient funds")
    }
    sa.Balance -= amount
    return nil
}

func (sa *SavingsAccount) AddInterest() {
    interest := sa.Balance * sa.InterestRate / 100
    sa.Balance += interest
    fmt.Printf("Interest added: $%.2f\n", interest)
}

// ë‹¹ì¢Œ ê³„ì¢Œ (BaseAccount ì„ë² ë”©)
type CheckingAccount struct {
    BaseAccount
    OverdraftLimit float64
}

func (ca *CheckingAccount) Withdraw(amount float64) error {
    if amount <= 0 {
        return errors.New("withdrawal amount must be positive")
    }
    if sa.Balance + ca.OverdraftLimit < amount {
        return errors.New("overdraft limit exceeded")
    }
    ca.Balance -= amount
    return nil
}

func (ca *CheckingAccount) GetOverdraftUsage() float64 {
    if ca.Balance >= 0 {
        return 0
    }
    return -ca.Balance
}

// ì€í–‰ ì‹œìŠ¤í…œ
type Bank struct {
    accounts map[string]Account
}

func NewBank() *Bank {
    return &Bank{
        accounts: make(map[string]Account),
    }
}

func (b *Bank) AddAccount(account Account) {
    accountInfo := account.GetAccountInfo()
    // ê³„ì¢Œ ë²ˆí˜¸ ì¶”ì¶œ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ë°©ë²• í•„ìš”)
    b.accounts[accountInfo] = account
}

func (b *Bank) ProcessTransaction(account Account, transactionType string, amount float64) {
    fmt.Printf("\n--- %s Transaction ---\n", transactionType)
    fmt.Printf("Before: %s\n", account.GetAccountInfo())
    
    var err error
    switch transactionType {
    case "Deposit":
        err = account.Deposit(amount)
    case "Withdraw":
        err = account.Withdraw(amount)
    }
    
    if err != nil {
        fmt.Printf("Transaction failed: %v\n", err)
    } else {
        fmt.Printf("Transaction successful: $%.2f\n", amount)
    }
    
    fmt.Printf("After: %s\n", account.GetAccountInfo())
}

func bankSystemExample() {
    bank := NewBank()
    
    // ì €ì¶• ê³„ì¢Œ ìƒì„±
    savings := &SavingsAccount{
        BaseAccount: BaseAccount{
            AccountNumber: "SAV001",
            Owner:         "Alice",
            Balance:       1000.0,
            CreatedAt:     time.Now(),
        },
        InterestRate: 2.5,
    }
    
    // ë‹¹ì¢Œ ê³„ì¢Œ ìƒì„±
    checking := &CheckingAccount{
        BaseAccount: BaseAccount{
            AccountNumber: "CHK001",
            Owner:         "Bob",
            Balance:       500.0,
            CreatedAt:     time.Now(),
        },
        OverdraftLimit: 200.0,
    }
    
    bank.AddAccount(savings)
    bank.AddAccount(checking)
    
    // ê±°ë˜ ì²˜ë¦¬
    bank.ProcessTransaction(savings, "Deposit", 200.0)
    bank.ProcessTransaction(savings, "Withdraw", 150.0)
    
    bank.ProcessTransaction(checking, "Deposit", 100.0)
    bank.ProcessTransaction(checking, "Withdraw", 800.0)  // í•œë„ ì´ˆê³¼ í…ŒìŠ¤íŠ¸
    bank.ProcessTransaction(checking, "Withdraw", 650.0)  // ì„±ê³µ
    
    // ì´ì ì¶”ê°€ (ì €ì¶• ê³„ì¢Œë§Œ)
    fmt.Println("\n--- Interest Calculation ---")
    savings.AddInterest()
    fmt.Printf("After interest: %s\n", savings.GetAccountInfo())
    
    // ì˜¤ë²„ë“œë˜í”„íŠ¸ ì‚¬ìš©ëŸ‰ í™•ì¸ (ë‹¹ì¢Œ ê³„ì¢Œë§Œ)
    fmt.Printf("Overdraft usage: $%.2f\n", checking.GetOverdraftUsage())
}
```

### ğŸ“ ì—°ìŠµ ë¬¸ì œ 2: ê²Œì„ ìºë¦­í„° ì‹œìŠ¤í…œ

```go
// ìºë¦­í„° ì¸í„°í˜ì´ìŠ¤
type Character interface {
    Attack() int
    TakeDamage(damage int)
    IsAlive() bool
    GetStatus() string
}

// ê¸°ë³¸ ìºë¦­í„°
type BaseCharacter struct {
    Name      string
    HP        int
    MaxHP     int
    AttackPower int
}

func (bc *BaseCharacter) TakeDamage(damage int) {
    bc.HP -= damage
    if bc.HP < 0 {
        bc.HP = 0
    }
}

func (bc *BaseCharacter) IsAlive() bool {
    return bc.HP > 0
}

func (bc *BaseCharacter) GetStatus() string {
    return fmt.Sprintf("%s: HP %d/%d", bc.Name, bc.HP, bc.MaxHP)
}

// ì „ì‚¬ (BaseCharacter ì„ë² ë”©)
type Warrior struct {
    BaseCharacter
    Armor int
}

func (w *Warrior) Attack() int {
    return w.AttackPower + 5  // ì „ì‚¬ëŠ” ì¶”ê°€ ê³µê²©ë ¥
}

func (w *Warrior) TakeDamage(damage int) {
    reducedDamage := damage - w.Armor
    if reducedDamage < 0 {
        reducedDamage = 0
    }
    w.BaseCharacter.TakeDamage(reducedDamage)
}

// ë§ˆë²•ì‚¬ (BaseCharacter ì„ë² ë”©)
type Mage struct {
    BaseCharacter
    Mana    int
    MaxMana int
}

func (m *Mage) Attack() int {
    return w.AttackPower
}

func (m *Mage) CastSpell() int {
    if m.Mana >= 10 {
        m.Mana -= 10
        return m.AttackPower * 2  // ë§ˆë²•ì€ 2ë°° ë°ë¯¸ì§€
    }
    return m.Attack()  // ë§ˆë‚˜ê°€ ì—†ìœ¼ë©´ ì¼ë°˜ ê³µê²©
}

func gameExample() {
    warrior := &Warrior{
        BaseCharacter: BaseCharacter{
            Name:        "Knight",
            HP:          100,
            MaxHP:       100,
            AttackPower: 20,
        },
        Armor: 5,
    }
    
    mage := &Mage{
        BaseCharacter: BaseCharacter{
            Name:        "Wizard",
            HP:          70,
            MaxHP:       70,
            AttackPower: 15,
        },
        Mana:    50,
        MaxMana: 50,
    }
    
    // ì „íˆ¬ ì‹œë®¬ë ˆì´ì…˜
    fmt.Println("=== Battle Start ===")
    fmt.Printf("%s vs %s\n", warrior.Name, mage.Name)
    
    round := 1
    for warrior.IsAlive() && mage.IsAlive() {
        fmt.Printf("\n--- Round %d ---\n", round)
        
        // ì „ì‚¬ ê³µê²©
        if warrior.IsAlive() {
            damage := warrior.Attack()
            mage.TakeDamage(damage)
            fmt.Printf("%s attacks for %d damage\n", warrior.Name, damage)
            fmt.Printf("%s\n", mage.GetStatus())
        }
        
        // ë§ˆë²•ì‚¬ ê³µê²©
        if mage.IsAlive() {
            damage := mage.CastSpell()
            warrior.TakeDamage(damage)
            fmt.Printf("%s casts spell for %d damage\n", mage.Name, damage)
            fmt.Printf("%s\n", warrior.GetStatus())
        }
        
        round++
        if round > 10 {  // ë¬´í•œ ë£¨í”„ ë°©ì§€
            break
        }
    }
    
    fmt.Println("\n=== Battle End ===")
    if warrior.IsAlive() {
        fmt.Printf("%s wins!\n", warrior.Name)
    } else if mage.IsAlive() {
        fmt.Printf("%s wins!\n", mage.Name)
    } else {
        fmt.Println("Draw!")
    }
}
```

---

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸

### êµ¬ì¡°ì²´
- [ ] êµ¬ì¡°ì²´ ì •ì˜ì™€ ì´ˆê¸°í™”
- [ ] êµ¬ì¡°ì²´ íƒœê·¸ í™œìš©
- [ ] ì¤‘ì²© êµ¬ì¡°ì²´ì™€ ìê¸° ì°¸ì¡°
- [ ] êµ¬ì¡°ì²´ ë³µì‚¬ì™€ í¬ì¸í„°

### ë©”ì„œë“œ
- [ ] ê°’ ë¦¬ì‹œë²„ vs í¬ì¸í„° ë¦¬ì‹œë²„
- [ ] ë©”ì„œë“œ ì •ì˜ì™€ í˜¸ì¶œ
- [ ] String() ë©”ì„œë“œ êµ¬í˜„
- [ ] ë©”ì„œë“œ ì²´ì´ë‹ íŒ¨í„´

### ì¸í„°í˜ì´ìŠ¤
- [ ] ì¸í„°í˜ì´ìŠ¤ ì •ì˜ì™€ êµ¬í˜„
- [ ] ì•”ì‹œì  ì¸í„°í˜ì´ìŠ¤ ì´í•´
- [ ] ë¹ˆ ì¸í„°í˜ì´ìŠ¤ í™œìš©
- [ ] íƒ€ì… assertionê³¼ íƒ€ì… ìŠ¤ìœ„ì¹˜

### ì„ë² ë”©ê³¼ ì»´í¬ì§€ì…˜
- [ ] êµ¬ì¡°ì²´ ì„ë² ë”© ì´í•´
- [ ] ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ
- [ ] ì»´í¬ì§€ì…˜ vs ìƒì†
- [ ] ì¸í„°í˜ì´ìŠ¤ ì„ë² ë”©

---

> [!tip] ë‹¤ìŒ ë‹¨ê³„
> êµ¬ì¡°ì²´ì™€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ìµí˜”ë‹¤ë©´ [[04-GO-ë™ì‹œì„±-ê³ ë£¨í‹´-ì±„ë„|GO ë™ì‹œì„± - ê³ ë£¨í‹´ê³¼ ì±„ë„]]ë¡œ ë„˜ì–´ê°€ì„¸ìš”!