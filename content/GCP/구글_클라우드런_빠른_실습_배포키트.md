---
title: êµ¬ê¸€ í´ë¼ìš°ë“œëŸ° - ë¹ ë¥¸ ì‹¤ìŠµ ë°°í¬í‚¤íŠ¸
tags:
  - GCP
  - CloudRun
  - Docker
  - serverless
  - container
  - devops
aliases:
  - í´ë¼ìš°ë“œëŸ°ë°°í¬
  - GCPì„œë²„ë¦¬ìŠ¤
  - CloudRunì‹¤ìŠµ
date: 2025-11-30
category: GCP/CloudRun
status: ì™„ì„±
priority: ë†’ìŒ
---

# ğŸš€ êµ¬ê¸€ í´ë¼ìš°ë“œëŸ° ë¹ ë¥¸ ì‹¤ìŠµ ë°°í¬í‚¤íŠ¸

**ì‘ì„± ì‹œê°„**: 2025-11-30 15:21 KST

## ğŸ“‘ ëª©ì°¨
- [[#1. í´ë¼ìš°ë“œëŸ° í•µì‹¬ ê°œë…|í•µì‹¬ ê°œë…]]
- [[#2. í™˜ê²½ ì„¤ì • ë° ì¤€ë¹„|í™˜ê²½ ì„¤ì •]]
- [[#3. ìƒ˜í”Œ ì• í”Œë¦¬ì¼€ì´ì…˜ë“¤|ìƒ˜í”Œ ì•±ë“¤]]
- [[#4. ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ ëª¨ìŒ|ë°°í¬ ìŠ¤í¬ë¦½íŠ¸]]
- [[#5. ê³ ê¸‰ ì„¤ì • ë° ìµœì í™”|ê³ ê¸‰ ì„¤ì •]]
- [[#ğŸ¯ ì‹¤ì „ ë°°í¬ ì˜ˆì‹œ|ì‹¤ì „ ì˜ˆì‹œ]]

---

## 1. í´ë¼ìš°ë“œëŸ° í•µì‹¬ ê°œë…

> [!note] Cloud Runì´ë€?
> êµ¬ê¸€ì˜ ì™„ì „ ê´€ë¦¬í˜• ì„œë²„ë¦¬ìŠ¤ ì»¨í…Œì´ë„ˆ í”Œë«í¼ìœ¼ë¡œ, HTTP ìš”ì²­ì— ë”°ë¼ ìë™ìœ¼ë¡œ ìŠ¤ì¼€ì¼ë§ë˜ë©° ì‚¬ìš©í•œ ë§Œí¼ë§Œ ê³¼ê¸ˆë˜ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.

### ğŸ’¡ ì£¼ìš” íŠ¹ì§• ë° ì¥ì 

**ğŸ¤” ì§ˆë¬¸**: "ê¸°ì¡´ VMì´ë‚˜ GKE ëŒ€ì‹  Cloud Runì„ ì–¸ì œ ì‚¬ìš©í•´ì•¼ í• ê¹Œ?"

#### ğŸ“‹ Cloud Run í•µì‹¬ ì¥ì 

> [!example] ì„œë²„ë¦¬ìŠ¤ ì»¨í…Œì´ë„ˆì˜ ì´ì 
> 1. **ì™„ì „ ê´€ë¦¬**: ì¸í”„ë¼ ê´€ë¦¬ ë¶ˆí•„ìš”
> 2. **ìë™ ìŠ¤ì¼€ì¼ë§**: 0ì—ì„œ ìˆ˜ì²œ ê°œ ì¸ìŠ¤í„´ìŠ¤ê¹Œì§€ ìë™ í™•ì¥
> 3. **ë¹„ìš© íš¨ìœ¨**: ìš”ì²­ ì²˜ë¦¬ ì‹œê°„ë§Œ ê³¼ê¸ˆ
> 4. **ë¹ ë¥¸ ë°°í¬**: ì»¨í…Œì´ë„ˆ ì´ë¯¸ì§€ë§Œ ìˆìœ¼ë©´ ì¦‰ì‹œ ë°°í¬

#### ğŸ’» ì„œë¹„ìŠ¤ ë¹„êµí‘œ

| íŠ¹ì„± | Cloud Run | App Engine | GKE | Compute Engine |
|------|-----------|------------|-----|----------------|
| ê´€ë¦¬ ë³µì¡ë„ | ë‚®ìŒ | ë‚®ìŒ | ë†’ìŒ | ë§¤ìš° ë†’ìŒ |
| ìŠ¤ì¼€ì¼ë§ | ìë™ (0-1000) | ìë™ | ìˆ˜ë™/ìë™ | ìˆ˜ë™ |
| ë¹„ìš© | ì‚¬ìš©ëŸ‰ ê¸°ë°˜ | ì‚¬ìš©ëŸ‰ ê¸°ë°˜ | ìƒì‹œ ê³¼ê¸ˆ | ìƒì‹œ ê³¼ê¸ˆ |
| ì»¨í…Œì´ë„ˆ ì§€ì› | ë„¤ì´í‹°ë¸Œ | ì»¤ìŠ¤í…€ ëŸ°íƒ€ì„ | ë„¤ì´í‹°ë¸Œ | ìˆ˜ë™ ì„¤ì • |
| Cold Start | ìˆìŒ | ìˆìŒ | ì—†ìŒ | ì—†ìŒ |

#### ğŸ“Š ì í•©í•œ ì‚¬ìš© ì‚¬ë¡€

> [!tip] Cloud Run ìµœì  í™œìš© ì‹œë‚˜ë¦¬ì˜¤
> **âœ… ì í•©í•œ ê²½ìš°**:
> - API ì„œë²„, ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜
> - ì´ë²¤íŠ¸ ì²˜ë¦¬, ë°°ì¹˜ ì‘ì—…
> - ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜
> - íŠ¸ë˜í”½ ë³€ë™ì´ í° ì„œë¹„ìŠ¤
> 
> **âŒ ë¶€ì í•©í•œ ê²½ìš°**:
> - ì§€ì†ì ì¸ ì—°ê²°ì´ í•„ìš”í•œ ì„œë¹„ìŠ¤ (WebSocket ì¥ì‹œê°„)
> - ë†’ì€ ë©”ëª¨ë¦¬/CPUê°€ ì§€ì†ì ìœ¼ë¡œ í•„ìš”
> - ë¡œì»¬ íŒŒì¼ì‹œìŠ¤í…œì— ì˜ì¡´ì 
> - 15ë¶„ ì´ìƒì˜ ì¥ì‹œê°„ ì²˜ë¦¬

---

## 2. í™˜ê²½ ì„¤ì • ë° ì¤€ë¹„

> [!info] ì‚¬ì „ ì¤€ë¹„ ì‚¬í•­
> Google Cloud ê³„ì •, gcloud CLI, Dockerê°€ í•„ìš”í•©ë‹ˆë‹¤. ìˆœì„œëŒ€ë¡œ ì„¤ì •í•´ë³´ê² ìŠµë‹ˆë‹¤.

### ğŸ’¡ í•„ìˆ˜ ë„êµ¬ ì„¤ì¹˜ ë° ì„¤ì •

**ğŸ¤” ì§ˆë¬¸**: "ì²˜ìŒ ì‹œì‘í•  ë•Œ ì–´ë–¤ ë„êµ¬ë“¤ì„ ì„¤ì¹˜í•´ì•¼ í• ê¹Œ?"

#### ğŸ“‹ macOS í™˜ê²½ ì„¤ì • (Homebrew ì‚¬ìš©)

> [!example] í•„ìˆ˜ ë„êµ¬ ì„¤ì¹˜
> ```bash
> # Google Cloud CLI ì„¤ì¹˜
> brew install google-cloud-sdk
> 
> # Docker Desktop ì„¤ì¹˜ (GUIë¡œ ì„¤ì¹˜ ê¶Œì¥)
> brew install --cask docker
> 
> # ê¸°íƒ€ ìœ ìš©í•œ ë„êµ¬ë“¤
> brew install jq          # JSON íŒŒì‹±
> brew install httpie      # HTTP í´ë¼ì´ì–¸íŠ¸
> brew install dive        # Docker ì´ë¯¸ì§€ ë¶„ì„
> ```

#### ğŸ’» Google Cloud ì´ˆê¸° ì„¤ì •

```bash
# ğŸ“Š Google Cloud ì¸ì¦ ë° í”„ë¡œì íŠ¸ ì„¤ì •
# 1. Google Cloud ë¡œê·¸ì¸
gcloud auth login

# 2. í”„ë¡œì íŠ¸ ì„¤ì • (ê¸°ì¡´ í”„ë¡œì íŠ¸ ì‚¬ìš© ë˜ëŠ” ì‹ ê·œ ìƒì„±)
# í”„ë¡œì íŠ¸ ëª©ë¡ í™•ì¸
gcloud projects list

# í”„ë¡œì íŠ¸ ì„¤ì •
export PROJECT_ID="your-project-id"
gcloud config set project $PROJECT_ID

# 3. í•„ìˆ˜ API í™œì„±í™”
gcloud services enable run.googleapis.com
gcloud services enable cloudbuild.googleapis.com
gcloud services enable containerregistry.googleapis.com
gcloud services enable artifactregistry.googleapis.com

# 4. ê¸°ë³¸ ë¦¬ì „ ì„¤ì •
gcloud config set run/region asia-northeast3  # ì„œìš¸ ë¦¬ì „
```

#### ğŸ“Š í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

```bash
# ğŸ“‹ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ìš© í™˜ê²½ ë³€ìˆ˜
cat > ~/.cloudrun_env << 'EOF'
# Google Cloud ì„¤ì •
export PROJECT_ID="your-project-id"
export REGION="asia-northeast3"
export SERVICE_ACCOUNT_EMAIL="your-service-account@your-project.iam.gserviceaccount.com"

# Container Registry ì„¤ì •
export REGISTRY_URL="gcr.io"
export ARTIFACT_REGISTRY_URL="asia-northeast3-docker.pkg.dev"

# Cloud Run ê¸°ë³¸ ì„¤ì •
export DEFAULT_MEMORY="512Mi"
export DEFAULT_CPU="1"
export DEFAULT_CONCURRENCY="80"
export DEFAULT_TIMEOUT="300"

EOF

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
source ~/.cloudrun_env
echo "source ~/.cloudrun_env" >> ~/.zshrc  # ë˜ëŠ” ~/.bashrc
```

---

## 3. ìƒ˜í”Œ ì• í”Œë¦¬ì¼€ì´ì…˜ë“¤

> [!tip] ë‹¤ì–‘í•œ ì–¸ì–´ë³„ ì˜ˆì œ
> ì‹¤ì œ ë°°í¬ ê°€ëŠ¥í•œ ì™„ì „í•œ ìƒ˜í”Œ ì• í”Œë¦¬ì¼€ì´ì…˜ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.

### ğŸ’¡ Node.js Express ì•±

**ğŸ¤” ì§ˆë¬¸**: "ê°€ì¥ ê°„ë‹¨í•œ ì›¹ ì„œë²„ë¶€í„° ì‹œì‘í•´ë³´ì"

#### ğŸ“‹ Express.js ê¸°ë³¸ ì•± ìƒì„±

```javascript
// ğŸ“Š package.json
{
  "name": "cloudrun-express-app",
  "version": "1.0.0",
  "description": "Cloud Run Express sample",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

```javascript
// ğŸ“Š server.js
const express = require('express');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 8080;

// ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
app.use(cors());
app.use(express.json());

// í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸
app.get('/', (req, res) => {
  res.json({
    message: 'Hello from Cloud Run!',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// API ì—”ë“œí¬ì¸íŠ¸
app.get('/api/status', (req, res) => {
  res.json({
    status: 'healthy',
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    environment: process.env.NODE_ENV || 'development'
  });
});

app.post('/api/echo', (req, res) => {
  res.json({
    received: req.body,
    headers: req.headers,
    timestamp: new Date().toISOString()
  });
});

// ì—ëŸ¬ í•¸ë“¤ë§
app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({ error: 'Internal Server Error' });
});

// 404 ì²˜ë¦¬
app.use((req, res) => {
  res.status(404).json({ error: 'Not Found' });
});

// ì„œë²„ ì‹œì‘
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('Received SIGTERM, shutting down gracefully');
  process.exit(0);
});
```

#### ğŸ’» Dockerfile ì‘ì„±

```dockerfile
# ğŸ“Š Node.jsìš© ìµœì í™”ëœ Dockerfile
FROM node:18-alpine

# ë³´ì•ˆ ê°•í™”
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /app

# ì¢…ì†ì„± íŒŒì¼ ë³µì‚¬ (ìºì‹œ ìµœì í™”)
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œ ë³µì‚¬
COPY . .

# ê¶Œí•œ ì„¤ì •
RUN chown -R nodejs:nodejs /app
USER nodejs

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8080

# í—¬ìŠ¤ì²´í¬
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:8080/', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
CMD ["npm", "start"]
```

### ğŸ’¡ Python Flask ì•±

#### ğŸ“‹ Flask ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤

```python
# ğŸ“Š requirements.txt
Flask==2.3.3
gunicorn==21.2.0
requests==2.31.0
python-dotenv==1.0.0
```

```python
# ğŸ“Š app.py
from flask import Flask, request, jsonify
import os
import time
import json
from datetime import datetime

app = Flask(__name__)

@app.route('/')
def home():
    return jsonify({
        'message': 'Hello from Python Flask on Cloud Run!',
        'timestamp': datetime.now().isoformat(),
        'python_version': f"{os.sys.version}",
        'version': '1.0.0'
    })

@app.route('/api/health')
def health_check():
    return jsonify({
        'status': 'healthy',
        'uptime': time.time() - start_time,
        'environment': os.environ.get('FLASK_ENV', 'production')
    })

@app.route('/api/env')
def show_env():
    # í™˜ê²½ ë³€ìˆ˜ í‘œì‹œ (ë¯¼ê°í•œ ì •ë³´ ì œì™¸)
    safe_env = {k: v for k, v in os.environ.items() 
                if not any(secret in k.lower() for secret in ['password', 'key', 'secret', 'token'])}
    return jsonify(safe_env)

@app.route('/api/process', methods=['POST'])
def process_data():
    try:
        data = request.get_json()
        
        # ê°„ë‹¨í•œ ë°ì´í„° ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        processed = {
            'input': data,
            'processed_at': datetime.now().isoformat(),
            'result': f"Processed {len(str(data))} characters"
        }
        
        return jsonify(processed)
    except Exception as e:
        return jsonify({'error': str(e)}), 400

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

# ì‹œì‘ ì‹œê°„ ê¸°ë¡
start_time = time.time()

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8080))
    debug = os.environ.get('FLASK_ENV') == 'development'
    app.run(host='0.0.0.0', port=port, debug=debug)
```

```dockerfile
# ğŸ“Š Pythonìš© ìµœì í™”ëœ Dockerfile
FROM python:3.11-slim

# ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ ë° í•„ìˆ˜ íŒ¨í‚¤ì§€
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# ë³´ì•ˆ ê°•í™”
RUN groupadd -r appuser && useradd -r -g appuser appuser

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /app

# Python ì¢…ì†ì„± ì„¤ì¹˜
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œ ë³µì‚¬
COPY . .

# ê¶Œí•œ ì„¤ì •
RUN chown -R appuser:appuser /app
USER appuser

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8080

# Gunicornìœ¼ë¡œ ì‹¤í–‰ (í”„ë¡œë•ì…˜ ê¶Œì¥)
CMD ["gunicorn", "--bind", "0.0.0.0:8080", "--workers", "2", "--timeout", "300", "app:app"]
```

### ğŸ’¡ Go ì›¹ ì„œë²„

#### ğŸ“‹ ê³ ì„±ëŠ¥ Go ì• í”Œë¦¬ì¼€ì´ì…˜

```go
// ğŸ“Š main.go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "runtime"
    "syscall"
    "time"
)

type Response struct {
    Message   string `json:"message"`
    Timestamp string `json:"timestamp"`
    Version   string `json:"version"`
}

type HealthResponse struct {
    Status      string            `json:"status"`
    Uptime      float64          `json:"uptime"`
    GoVersion   string           `json:"go_version"`
    NumGoroutine int             `json:"num_goroutine"`
    Memory      runtime.MemStats `json:"memory"`
}

var startTime = time.Now()

func main() {
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }

    mux := http.NewServeMux()
    
    // ë¼ìš°íŠ¸ ì„¤ì •
    mux.HandleFunc("/", homeHandler)
    mux.HandleFunc("/api/health", healthHandler)
    mux.HandleFunc("/api/process", processHandler)

    // ë¯¸ë“¤ì›¨ì–´ ì¶”ê°€
    handler := loggingMiddleware(corsMiddleware(mux))

    server := &http.Server{
        Addr:         ":" + port,
        Handler:      handler,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // Graceful shutdown ì„¤ì •
    go func() {
        log.Printf("Server starting on port %s", port)
        if err := server.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatalf("Server failed to start: %v", err)
        }
    }()

    // ì¢…ë£Œ ì‹ í˜¸ ëŒ€ê¸°
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    log.Println("Server is shutting down...")
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    if err := server.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }
    log.Println("Server exited")
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
    response := Response{
        Message:   "Hello from Go on Cloud Run!",
        Timestamp: time.Now().Format(time.RFC3339),
        Version:   "1.0.0",
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
    var memStats runtime.MemStats
    runtime.GC()
    runtime.ReadMemStats(&memStats)

    response := HealthResponse{
        Status:       "healthy",
        Uptime:       time.Since(startTime).Seconds(),
        GoVersion:    runtime.Version(),
        NumGoroutine: runtime.NumGoroutine(),
        Memory:       memStats,
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func processHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    var data map[string]interface{}
    if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }

    result := map[string]interface{}{
        "input":        data,
        "processed_at": time.Now().Format(time.RFC3339),
        "server":       "Go Cloud Run",
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(result)
}

func corsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }

        next.ServeHTTP(w, r)
    })
}

func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        log.Printf("%s %s %s", r.Method, r.URL.Path, time.Since(start))
    })
}
```

```dockerfile
# ğŸ“Š Goìš© ë©€í‹°ìŠ¤í…Œì´ì§€ Dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

# ë³´ì•ˆ íŒ¨í‚¤ì§€ ì„¤ì¹˜
RUN apk add --no-cache git ca-certificates tzdata

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /app

# Go modules íŒŒì¼ ë³µì‚¬
COPY go.mod go.sum ./
RUN go mod download

# ì†ŒìŠ¤ ì½”ë“œ ë³µì‚¬
COPY . .

# ë°”ì´ë„ˆë¦¬ ë¹Œë“œ
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Production stage
FROM alpine:latest

# ë³´ì•ˆ ì—…ë°ì´íŠ¸ ë° CA ì¸ì¦ì„œ
RUN apk --no-cache add ca-certificates tzdata
RUN adduser -D -s /bin/sh appuser

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /root/

# ë¹Œë“œëœ ë°”ì´ë„ˆë¦¬ ë³µì‚¬
COPY --from=builder /app/main .

# ê¶Œí•œ ì„¤ì •
RUN chown appuser:appuser main
USER appuser

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8080

# ì‹¤í–‰
CMD ["./main"]
```

```go
// ğŸ“Š go.mod
module cloudrun-go-app

go 1.21
```

---

## 4. ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ ëª¨ìŒ

> [!tip] ì›í´ë¦­ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸
> ë³µì¡í•œ ëª…ë ¹ì–´ë“¤ì„ ìë™í™”í•˜ì—¬ ë¹ ë¥´ê³  ì•ˆì „í•˜ê²Œ ë°°í¬í•  ìˆ˜ ìˆëŠ” ìŠ¤í¬ë¦½íŠ¸ë“¤ì…ë‹ˆë‹¤.

### ğŸ’¡ ë²”ìš© ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

**ğŸ¤” ì§ˆë¬¸**: "ë§¤ë²ˆ ê¸´ ëª…ë ¹ì–´ë¥¼ ì¹˜ê¸° ë²ˆê±°ë¡œìš´ë°, ìŠ¤í¬ë¦½íŠ¸ë¡œ ìë™í™”í•  ìˆ˜ ì—†ì„ê¹Œ?"

#### ğŸ“‹ ë©”ì¸ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

```bash
#!/bin/bash
# ğŸ“Š deploy-to-cloudrun.sh - ë²”ìš© Cloud Run ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

set -e  # ì˜¤ë¥˜ ë°œìƒì‹œ ìŠ¤í¬ë¦½íŠ¸ ì¤‘ë‹¨

# ìƒ‰ìƒ ì¶œë ¥ í•¨ìˆ˜
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
if [[ -f ~/.cloudrun_env ]]; then
    source ~/.cloudrun_env
    log_info "Environment variables loaded"
else
    log_error "Environment file not found. Run setup first."
    exit 1
fi

# íŒŒë¼ë¯¸í„° íŒŒì‹±
SERVICE_NAME=""
IMAGE_TAG="latest"
MEMORY="512Mi"
CPU="1"
CONCURRENCY="80"
MAX_INSTANCES="100"
MIN_INSTANCES="0"
TIMEOUT="300"
ENV_VARS=""
ALLOW_UNAUTHENTICATED="true"

show_help() {
    cat << EOF
Cloud Run ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

ì‚¬ìš©ë²•: $0 [ì˜µì…˜]

í•„ìˆ˜ íŒŒë¼ë¯¸í„°:
  -n, --name SERVICE_NAME        ì„œë¹„ìŠ¤ ì´ë¦„

ì„ íƒì  íŒŒë¼ë¯¸í„°:
  -t, --tag TAG                  ì´ë¯¸ì§€ íƒœê·¸ (ê¸°ë³¸ê°’: latest)
  -m, --memory MEMORY           ë©”ëª¨ë¦¬ í• ë‹¹ (ê¸°ë³¸ê°’: 512Mi)
  -c, --cpu CPU                 CPU í• ë‹¹ (ê¸°ë³¸ê°’: 1)
  --concurrency NUM             ë™ì‹œ ìš”ì²­ ìˆ˜ (ê¸°ë³¸ê°’: 80)
  --max-instances NUM           ìµœëŒ€ ì¸ìŠ¤í„´ìŠ¤ (ê¸°ë³¸ê°’: 100)
  --min-instances NUM           ìµœì†Œ ì¸ìŠ¤í„´ìŠ¤ (ê¸°ë³¸ê°’: 0)
  --timeout SECONDS             íƒ€ì„ì•„ì›ƒ (ê¸°ë³¸ê°’: 300)
  --env-vars "KEY1=VALUE1,KEY2=VALUE2"  í™˜ê²½ ë³€ìˆ˜
  --no-allow-unauthenticated    ì¸ì¦ í•„ìš” ì„¤ì •
  -h, --help                    ë„ì›€ë§ í‘œì‹œ

ì˜ˆì‹œ:
  $0 -n my-app -t v1.0.0 -m 1Gi --env-vars "NODE_ENV=production,DEBUG=false"
EOF
}

# íŒŒë¼ë¯¸í„° íŒŒì‹±
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--name)
            SERVICE_NAME="$2"
            shift 2
            ;;
        -t|--tag)
            IMAGE_TAG="$2"
            shift 2
            ;;
        -m|--memory)
            MEMORY="$2"
            shift 2
            ;;
        -c|--cpu)
            CPU="$2"
            shift 2
            ;;
        --concurrency)
            CONCURRENCY="$2"
            shift 2
            ;;
        --max-instances)
            MAX_INSTANCES="$2"
            shift 2
            ;;
        --min-instances)
            MIN_INSTANCES="$2"
            shift 2
            ;;
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --env-vars)
            ENV_VARS="$2"
            shift 2
            ;;
        --no-allow-unauthenticated)
            ALLOW_UNAUTHENTICATED="false"
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown option $1"
            show_help
            exit 1
            ;;
    esac
done

# í•„ìˆ˜ íŒŒë¼ë¯¸í„° ê²€ì¦
if [[ -z "$SERVICE_NAME" ]]; then
    log_error "Service name is required"
    show_help
    exit 1
fi

# ì´ë¯¸ì§€ ì´ë¦„ êµ¬ì„±
IMAGE_NAME="gcr.io/$PROJECT_ID/$SERVICE_NAME:$IMAGE_TAG"

log_info "Starting deployment..."
log_info "Service: $SERVICE_NAME"
log_info "Image: $IMAGE_NAME"
log_info "Region: $REGION"

# 1. Dockerfile ì¡´ì¬ í™•ì¸
if [[ ! -f "Dockerfile" ]]; then
    log_error "Dockerfile not found in current directory"
    exit 1
fi

# 2. Docker ì´ë¯¸ì§€ ë¹Œë“œ
log_info "Building Docker image..."
docker build -t "$IMAGE_NAME" .
log_success "Docker image built successfully"

# 3. ì´ë¯¸ì§€ í‘¸ì‹œ
log_info "Pushing image to Container Registry..."
docker push "$IMAGE_NAME"
log_success "Image pushed successfully"

# 4. Cloud Run ë°°í¬ ëª…ë ¹ì–´ êµ¬ì„±
DEPLOY_CMD="gcloud run deploy $SERVICE_NAME \
  --image $IMAGE_NAME \
  --platform managed \
  --region $REGION \
  --memory $MEMORY \
  --cpu $CPU \
  --concurrency $CONCURRENCY \
  --max-instances $MAX_INSTANCES \
  --min-instances $MIN_INSTANCES \
  --timeout $TIMEOUT"

# í™˜ê²½ ë³€ìˆ˜ ì¶”ê°€
if [[ -n "$ENV_VARS" ]]; then
    DEPLOY_CMD="$DEPLOY_CMD --set-env-vars $ENV_VARS"
fi

# ì¸ì¦ ì„¤ì •
if [[ "$ALLOW_UNAUTHENTICATED" == "true" ]]; then
    DEPLOY_CMD="$DEPLOY_CMD --allow-unauthenticated"
fi

# 5. ë°°í¬ ì‹¤í–‰
log_info "Deploying to Cloud Run..."
eval $DEPLOY_CMD
log_success "Deployment completed successfully"

# 6. ì„œë¹„ìŠ¤ URL í™•ì¸
SERVICE_URL=$(gcloud run services describe $SERVICE_NAME --region=$REGION --format="value(status.url)")
log_success "Service is available at: $SERVICE_URL"

# 7. ë°°í¬ ì •ë³´ ì¶œë ¥
log_info "Deployment Summary:"
echo "  Service Name: $SERVICE_NAME"
echo "  Image: $IMAGE_NAME"
echo "  Region: $REGION"
echo "  URL: $SERVICE_URL"
echo "  Memory: $MEMORY"
echo "  CPU: $CPU"
echo "  Concurrency: $CONCURRENCY"

# 8. í—¬ìŠ¤ ì²´í¬ (ì„ íƒì )
log_info "Testing service..."
if curl -s "$SERVICE_URL" > /dev/null; then
    log_success "Service is responding correctly"
else
    log_warning "Service might not be ready yet. Please check manually."
fi

log_success "Deployment completed! ğŸš€"
```

#### ğŸ’» ê°œë°œí™˜ê²½ìš© ë¹ ë¥¸ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

```bash
#!/bin/bash
# ğŸ“Š quick-deploy.sh - ê°œë°œìš© ë¹ ë¥¸ ë°°í¬

set -e

# ê¸°ë³¸ ì„¤ì •
SERVICE_NAME=${1:-"my-dev-app"}
IMAGE_TAG=${2:-"dev-$(date +%s)"}

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
source ~/.cloudrun_env 2>/dev/null || {
    echo "Error: Environment file not found"
    exit 1
}

echo "ğŸš€ Quick Deploy to Cloud Run"
echo "Service: $SERVICE_NAME"
echo "Tag: $IMAGE_TAG"

# ì›í´ë¦­ ë°°í¬
gcloud run deploy $SERVICE_NAME \
  --source . \
  --platform managed \
  --region $REGION \
  --allow-unauthenticated \
  --memory 512Mi \
  --cpu 1 \
  --concurrency 80 \
  --max-instances 10 \
  --set-env-vars "NODE_ENV=development,DEBUG=true"

# URL ì¶œë ¥
URL=$(gcloud run services describe $SERVICE_NAME --region=$REGION --format="value(status.url)")
echo "âœ… Deployed: $URL"

# ë¸Œë¼ìš°ì €ì—ì„œ ì—´ê¸° (macOS)
[[ "$OSTYPE" =~ ^darwin ]] && open "$URL"
```

### ğŸ’¡ CI/CD íŒŒì´í”„ë¼ì¸ìš© ìŠ¤í¬ë¦½íŠ¸

#### ğŸ“‹ GitHub Actions ì›Œí¬í”Œë¡œìš°

```yaml
# ğŸ“Š .github/workflows/deploy-to-cloudrun.yml
name: Deploy to Cloud Run

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SERVICE_NAME: my-cloudrun-app
  REGION: asia-northeast3

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v1
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        service_account_key: ${{ secrets.GCP_SA_KEY }}
        export_default_credentials: true

    - name: Configure Docker
      run: gcloud auth configure-docker

    - name: Build Docker image
      run: |
        docker build -t gcr.io/$PROJECT_ID/$SERVICE_NAME:$GITHUB_SHA .
        docker build -t gcr.io/$PROJECT_ID/$SERVICE_NAME:latest .

    - name: Push Docker image
      run: |
        docker push gcr.io/$PROJECT_ID/$SERVICE_NAME:$GITHUB_SHA
        docker push gcr.io/$PROJECT_ID/$SERVICE_NAME:latest

    - name: Deploy to Cloud Run
      run: |
        gcloud run deploy $SERVICE_NAME \
          --image gcr.io/$PROJECT_ID/$SERVICE_NAME:$GITHUB_SHA \
          --platform managed \
          --region $REGION \
          --allow-unauthenticated \
          --memory 512Mi \
          --cpu 1 \
          --concurrency 80 \
          --max-instances 100 \
          --set-env-vars "NODE_ENV=production"

    - name: Get service URL
      run: |
        SERVICE_URL=$(gcloud run services describe $SERVICE_NAME --region=$REGION --format="value(status.url)")
        echo "Service URL: $SERVICE_URL"
        
    - name: Test deployment
      run: |
        SERVICE_URL=$(gcloud run services describe $SERVICE_NAME --region=$REGION --format="value(status.url)")
        curl -f $SERVICE_URL || exit 1
```

### ğŸ’¡ ë¡œì»¬ ê°œë°œ ë„êµ¬ ìŠ¤í¬ë¦½íŠ¸

#### ğŸ“‹ ê°œë°œ í™˜ê²½ í†µí•© ìŠ¤í¬ë¦½íŠ¸

```bash
#!/bin/bash
# ğŸ“Š dev-tools.sh - ë¡œì»¬ ê°œë°œ ë„êµ¬ ëª¨ìŒ

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SERVICE_NAME="my-dev-app"

show_menu() {
    echo ""
    echo "ğŸ› ï¸  Cloud Run ê°œë°œ ë„êµ¬"
    echo "========================"
    echo "1. ë¡œì»¬ Docker ì‹¤í–‰"
    echo "2. Cloud Run ë°°í¬"
    echo "3. ë¡œê·¸ ë³´ê¸°"
    echo "4. ì„œë¹„ìŠ¤ ì‚­ì œ"
    echo "5. íŠ¸ë˜í”½ ë¶„í•  ì„¤ì •"
    echo "6. ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸"
    echo "0. ì¢…ë£Œ"
    echo ""
}

run_locally() {
    echo "ğŸƒ ë¡œì»¬ì—ì„œ Docker ì»¨í…Œì´ë„ˆ ì‹¤í–‰..."
    
    # ì´ë¯¸ì§€ ë¹Œë“œ
    docker build -t $SERVICE_NAME:local .
    
    # ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ì •ì§€ ë° ì‚­ì œ
    docker stop $SERVICE_NAME 2>/dev/null || true
    docker rm $SERVICE_NAME 2>/dev/null || true
    
    # ìƒˆ ì»¨í…Œì´ë„ˆ ì‹¤í–‰
    docker run -d \
      --name $SERVICE_NAME \
      -p 8080:8080 \
      -e NODE_ENV=development \
      $SERVICE_NAME:local
    
    echo "âœ… ì»¨í…Œì´ë„ˆê°€ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤: http://localhost:8080"
    
    # ë¡œê·¸ ì¶”ì 
    echo "ğŸ“‹ ë¡œê·¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤ (Ctrl+Cë¡œ ì¤‘ë‹¨):"
    docker logs -f $SERVICE_NAME
}

deploy_to_cloudrun() {
    echo "â˜ï¸  Cloud Runì— ë°°í¬ì¤‘..."
    ./deploy-to-cloudrun.sh -n $SERVICE_NAME -t "dev-$(date +%s)"
}

show_logs() {
    echo "ğŸ“‹ Cloud Run ë¡œê·¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤..."
    gcloud logs tail cloudrun.googleapis.com/$SERVICE_NAME \
      --region=$REGION \
      --format="table(timestamp,severity,textPayload)"
}

delete_service() {
    echo "ğŸ—‘ï¸  ì„œë¹„ìŠ¤ ì‚­ì œ í™•ì¸"
    read -p "ì •ë§ë¡œ '$SERVICE_NAME' ì„œë¹„ìŠ¤ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        gcloud run services delete $SERVICE_NAME --region=$REGION --quiet
        echo "âœ… ì„œë¹„ìŠ¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."
    else
        echo "âŒ ì‚­ì œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
    fi
}

setup_traffic_split() {
    echo "ğŸš¦ íŠ¸ë˜í”½ ë¶„í•  ì„¤ì •"
    echo "í˜„ì¬ ë°°í¬ëœ ë¦¬ë¹„ì „ë“¤:"
    
    gcloud run revisions list --service=$SERVICE_NAME --region=$REGION
    
    echo ""
    read -p "ìƒˆ ë¦¬ë¹„ì „ì˜ íŠ¸ë˜í”½ ë¹„ìœ¨ì„ ì…ë ¥í•˜ì„¸ìš” (0-100): " traffic_percent
    
    if [[ "$traffic_percent" =~ ^[0-9]+$ ]] && [ "$traffic_percent" -le 100 ]; then
        gcloud run services update-traffic $SERVICE_NAME \
          --region=$REGION \
          --to-latest=$traffic_percent
        echo "âœ… íŠ¸ë˜í”½ ë¶„í• ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤."
    else
        echo "âŒ ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤."
    fi
}

check_service_status() {
    echo "ğŸ“Š ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸"
    
    # ì„œë¹„ìŠ¤ ê¸°ë³¸ ì •ë³´
    echo "=== ì„œë¹„ìŠ¤ ì •ë³´ ==="
    gcloud run services describe $SERVICE_NAME \
      --region=$REGION \
      --format="table(metadata.name,status.url,status.latestReadyRevisionName,spec.traffic[].percent)"
    
    echo ""
    echo "=== ìµœê·¼ ë¦¬ë¹„ì „ë“¤ ==="
    gcloud run revisions list \
      --service=$SERVICE_NAME \
      --region=$REGION \
      --limit=5 \
      --format="table(metadata.name,status.conditions[0].lastTransitionTime,spec.containerConcurrency,status.allocatedInstances)"
    
    echo ""
    echo "=== ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ==="
    SERVICE_URL=$(gcloud run services describe $SERVICE_NAME --region=$REGION --format="value(status.url)")
    if [[ -n "$SERVICE_URL" ]]; then
        echo "URL: $SERVICE_URL"
        echo "ì‘ë‹µ í…ŒìŠ¤íŠ¸ì¤‘..."
        
        response_time=$(curl -o /dev/null -s -w '%{time_total}' "$SERVICE_URL" || echo "failed")
        if [[ "$response_time" != "failed" ]]; then
            echo "âœ… ì‘ë‹µ ì‹œê°„: ${response_time}ì´ˆ"
        else
            echo "âŒ ì„œë¹„ìŠ¤ ì‘ë‹µ ì—†ìŒ"
        fi
    fi
}

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
source ~/.cloudrun_env 2>/dev/null || {
    echo "âŒ í™˜ê²½ ì„¤ì • íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
    echo "setup-environment.shë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”."
    exit 1
}

# ë©”ì¸ ë£¨í”„
while true; do
    show_menu
    read -p "ì„ íƒí•˜ì„¸ìš” (0-6): " choice
    
    case $choice in
        1) run_locally ;;
        2) deploy_to_cloudrun ;;
        3) show_logs ;;
        4) delete_service ;;
        5) setup_traffic_split ;;
        6) check_service_status ;;
        0) echo "ğŸ‘‹ ì¢…ë£Œí•©ë‹ˆë‹¤."; exit 0 ;;
        *) echo "âŒ ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤." ;;
    esac
    
    echo ""
    read -p "ê³„ì†í•˜ë ¤ë©´ Enterë¥¼ ëˆ„ë¥´ì„¸ìš”..."
done
```

---

## 5. ê³ ê¸‰ ì„¤ì • ë° ìµœì í™”

> [!info] í”„ë¡œë•ì…˜ ì¤€ë¹„
> ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œ í•„ìš”í•œ ê³ ê¸‰ ì„¤ì •ë“¤ê³¼ ì„±ëŠ¥ ìµœì í™” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

### ğŸ’¡ ë³´ì•ˆ ë° IAM ì„¤ì •

**ğŸ¤” ì§ˆë¬¸**: "í”„ë¡œë•ì…˜ì—ì„œ ë³´ì•ˆì„ ì–´ë–»ê²Œ ê°•í™”í• ê¹Œ?"

#### ğŸ“‹ ì„œë¹„ìŠ¤ ê³„ì • ë° IAM ì„¤ì •

```bash
#!/bin/bash
# ğŸ“Š setup-security.sh - ë³´ì•ˆ ì„¤ì • ìë™í™”

# ì„œë¹„ìŠ¤ ê³„ì • ìƒì„±
SERVICE_ACCOUNT_NAME="cloudrun-sa"
SERVICE_ACCOUNT_EMAIL="$SERVICE_ACCOUNT_NAME@$PROJECT_ID.iam.gserviceaccount.com"

echo "ğŸ” ë³´ì•ˆ ì„¤ì •ì„ ì‹œì‘í•©ë‹ˆë‹¤..."

# 1. ì„œë¹„ìŠ¤ ê³„ì • ìƒì„±
gcloud iam service-accounts create $SERVICE_ACCOUNT_NAME \
  --description="Cloud Run service account" \
  --display-name="Cloud Run Service Account"

# 2. í•„ìš”í•œ ê¶Œí•œë§Œ ë¶€ì—¬ (ìµœì†Œ ê¶Œí•œ ì›ì¹™)
gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
  --role="roles/cloudtrace.agent"

gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
  --role="roles/logging.logWriter"

gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
  --role="roles/monitoring.metricWriter"

# 3. í‚¤ ìƒì„± ë° ë‹¤ìš´ë¡œë“œ
gcloud iam service-accounts keys create ~/cloudrun-sa-key.json \
  --iam-account=$SERVICE_ACCOUNT_EMAIL

echo "âœ… ì„œë¹„ìŠ¤ ê³„ì •ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: $SERVICE_ACCOUNT_EMAIL"
echo "ğŸ”‘ í‚¤ íŒŒì¼: ~/cloudrun-sa-key.json"

# 4. VPC Connector ì„¤ì • (Private Google Accessìš©)
echo "ğŸ”Œ VPC Connector ì„¤ì •..."
gcloud compute networks vpc-access connectors create cloudrun-connector \
  --region=$REGION \
  --subnet=default \
  --subnet-project=$PROJECT_ID \
  --min-instances=2 \
  --max-instances=3

echo "âœ… ë³´ì•ˆ ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
```

#### ğŸ’» ë³´ì•ˆ ê°•í™”ëœ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

```bash
#!/bin/bash
# ğŸ“Š secure-deploy.sh - ë³´ì•ˆ ê°•í™” ë°°í¬

SERVICE_NAME="$1"
if [[ -z "$SERVICE_NAME" ]]; then
    echo "Usage: $0 <service-name>"
    exit 1
fi

# ë³´ì•ˆ ì„¤ì •ìœ¼ë¡œ ë°°í¬
gcloud run deploy $SERVICE_NAME \
  --image "gcr.io/$PROJECT_ID/$SERVICE_NAME:latest" \
  --platform managed \
  --region $REGION \
  --service-account="cloudrun-sa@$PROJECT_ID.iam.gserviceaccount.com" \
  --vpc-connector="cloudrun-connector" \
  --vpc-egress="private-ranges-only" \
  --no-allow-unauthenticated \
  --memory="1Gi" \
  --cpu="1" \
  --concurrency="80" \
  --max-instances="100" \
  --min-instances="1" \
  --timeout="300" \
  --execution-environment="gen2" \
  --cpu-throttling \
  --session-affinity \
  --set-env-vars="NODE_ENV=production" \
  --set-secrets="DB_PASSWORD=db-password:latest,API_KEY=api-key:latest"

echo "âœ… ë³´ì•ˆ ê°•í™”ëœ ë°°í¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
```

### ğŸ’¡ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ì„¤ì •

#### ğŸ“‹ ê³ ê¸‰ ë¡œê¹… êµ¬ì„±

```javascript
// ğŸ“Š logger.js - êµ¬ì¡°í™”ëœ ë¡œê¹…
const winston = require('winston');
const { LoggingWinston } = require('@google-cloud/logging-winston');

const loggingWinston = new LoggingWinston({
  projectId: process.env.GOOGLE_CLOUD_PROJECT,
  keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS,
  logName: 'cloudrun-app',
  resource: {
    type: 'cloud_run_revision',
    labels: {
      service_name: process.env.K_SERVICE || 'unknown',
      revision_name: process.env.K_REVISION || 'unknown',
      location: process.env.GOOGLE_CLOUD_REGION || 'unknown'
    }
  }
});

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: process.env.K_SERVICE || 'cloudrun-app',
    version: process.env.APP_VERSION || '1.0.0'
  },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    loggingWinston
  ]
});

// ìš”ì²­ ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
const requestLogger = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
      userAgent: req.get('User-Agent'),
      ip: req.ip,
      traceId: req.get('X-Cloud-Trace-Context')
    });
  });
  
  next();
};

module.exports = { logger, requestLogger };
```

#### ğŸ’» ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì„¤ì •

```javascript
// ğŸ“Š metrics.js - ì»¤ìŠ¤í…€ ë©”íŠ¸ë¦­
const { Monitoring } = require('@google-cloud/monitoring');

class CloudRunMetrics {
  constructor() {
    this.client = new Monitoring.MetricServiceClient();
    this.projectPath = this.client.projectPath(process.env.GOOGLE_CLOUD_PROJECT);
  }

  async recordCustomMetric(metricType, value, labels = {}) {
    const dataPoint = {
      interval: {
        endTime: {
          seconds: Date.now() / 1000,
        },
      },
      value: {
        doubleValue: value,
      },
    };

    const timeSeries = {
      metric: {
        type: `custom.googleapis.com/${metricType}`,
        labels: labels,
      },
      resource: {
        type: 'cloud_run_revision',
        labels: {
          service_name: process.env.K_SERVICE || 'unknown',
          revision_name: process.env.K_REVISION || 'unknown',
          location: process.env.GOOGLE_CLOUD_REGION || 'unknown',
        },
      },
      points: [dataPoint],
    };

    const request = {
      name: this.projectPath,
      timeSeries: [timeSeries],
    };

    try {
      await this.client.createTimeSeries(request);
    } catch (error) {
      console.error('Failed to record metric:', error);
    }
  }

  // ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­ ê¸°ë¡
  async recordBusinessMetric(action, value = 1, metadata = {}) {
    await this.recordCustomMetric('business_action', value, {
      action: action,
      ...metadata
    });
  }

  // ì„±ëŠ¥ ë©”íŠ¸ë¦­ ê¸°ë¡
  async recordPerformanceMetric(operation, duration, success = true) {
    await this.recordCustomMetric('operation_duration', duration, {
      operation: operation,
      success: success.toString()
    });
  }
}

module.exports = CloudRunMetrics;
```

### ğŸ’¡ ì„±ëŠ¥ ìµœì í™”

#### ğŸ“‹ ìµœì í™”ëœ Dockerfile

```dockerfile
# ğŸ“Š ìµœì í™”ëœ Node.js Dockerfile
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./

# ê°œë°œ ì˜ì¡´ì„± í¬í•¨ ì„¤ì¹˜
FROM base AS development
RUN npm ci
COPY . .
CMD ["npm", "run", "dev"]

# í”„ë¡œë•ì…˜ ë¹Œë“œ
FROM base AS build
RUN npm ci --only=production && npm cache clean --force
COPY . .
RUN npm run build

# í”„ë¡œë•ì…˜ ëŸ°íƒ€ì„
FROM node:18-alpine AS production

# ë³´ì•ˆ ì—…ë°ì´íŠ¸
RUN apk update && apk upgrade && apk add --no-cache dumb-init

# ì‚¬ìš©ì ìƒì„±
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /app

# ì†Œìœ ê¶Œ ë³€ê²½
RUN chown nodejs:nodejs /app
USER nodejs

# í”„ë¡œë•ì…˜ íŒŒì¼ë§Œ ë³µì‚¬
COPY --from=build --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=build --chown=nodejs:nodejs /app/dist ./dist
COPY --from=build --chown=nodejs:nodejs /app/package*.json ./

# í—¬ìŠ¤ì²´í¬
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:8080/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8080

# ì‹ í˜¸ ì²˜ë¦¬ë¥¼ ìœ„í•œ init ì‹œìŠ¤í…œ ì‚¬ìš©
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/server.js"]
```

#### ğŸ’» Cold Start ìµœì í™”

```javascript
// ğŸ“Š cold-start-optimization.js
// Cold Start ìµœì í™” ê¸°ë²•ë“¤

class ColdStartOptimizer {
  constructor() {
    this.isWarmedUp = false;
    this.warmupConnections = new Map();
    
    // ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ì‹œ ì¦‰ì‹œ ì›Œë°ì—…
    this.warmupApplication();
  }

  async warmupApplication() {
    console.log('ğŸ”¥ Warming up application...');
    
    // 1. ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ë¯¸ë¦¬ ìƒì„±
    await this.warmupDatabaseConnections();
    
    // 2. ì™¸ë¶€ API ì—°ê²° í…ŒìŠ¤íŠ¸
    await this.warmupExternalConnections();
    
    // 3. ìºì‹œ ë°ì´í„° ë¯¸ë¦¬ ë¡œë“œ
    await this.preloadCache();
    
    this.isWarmedUp = true;
    console.log('âœ… Application warmed up successfully');
  }

  async warmupDatabaseConnections() {
    // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ë¯¸ë¦¬ ìƒì„±
    const db = require('./database');
    await db.testConnection();
  }

  async warmupExternalConnections() {
    // ì™¸ë¶€ ì„œë¹„ìŠ¤ ì—°ê²° í…ŒìŠ¤íŠ¸
    const services = ['auth-service', 'payment-service'];
    
    for (const service of services) {
      try {
        const connection = await this.createConnection(service);
        this.warmupConnections.set(service, connection);
      } catch (error) {
        console.warn(`Failed to warmup ${service}:`, error.message);
      }
    }
  }

  async preloadCache() {
    // ìì£¼ ì‚¬ìš©ë˜ëŠ” ë°ì´í„° ìºì‹œì— ë¯¸ë¦¬ ë¡œë“œ
    const cache = require('./cache');
    await cache.preload([
      'frequently-used-config',
      'user-preferences-default'
    ]);
  }

  // ìš”ì²­ ì²˜ë¦¬ ì‹œ ì›Œë°ì—… ìƒíƒœ í™•ì¸
  isReady() {
    return this.isWarmedUp;
  }

  // í—¬ìŠ¤ì²´í¬ì—ì„œ ì›Œë°ì—… ìƒíƒœ í¬í•¨
  getHealthStatus() {
    return {
      status: this.isWarmedUp ? 'ready' : 'warming-up',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      warmedConnections: Array.from(this.warmupConnections.keys())
    };
  }
}

// ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
const optimizer = new ColdStartOptimizer();

// Express ë¯¸ë“¤ì›¨ì–´
const warmupMiddleware = (req, res, next) => {
  if (!optimizer.isReady() && req.path !== '/health') {
    return res.status(503).json({
      error: 'Service warming up',
      retryAfter: 5
    });
  }
  next();
};

module.exports = { optimizer, warmupMiddleware };
```

---

## ğŸ¯ ì‹¤ì „ ë°°í¬ ì˜ˆì‹œ: ì¢…í•© ì‹œë‚˜ë¦¬ì˜¤

> [!example] ì™„ì „í•œ ë°°í¬ íŒŒì´í”„ë¼ì¸
> ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì¢…í•©ì ì¸ ë°°í¬ ì˜ˆì‹œë¥¼ í†µí•´ ëª¨ë“  ê°œë…ì„ í†µí•©í•´ë´…ë‹ˆë‹¤.

### ğŸ’» í†µí•© ë°°í¬ ì‹œë‚˜ë¦¬ì˜¤

```bash
#!/bin/bash
# ğŸ“Š production-deployment.sh - í”„ë¡œë•ì…˜ ì™„ì „ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

set -euo pipefail

# ì„¤ì • ë³€ìˆ˜ë“¤
SERVICE_NAME="ecommerce-api"
ENVIRONMENT="production"
VERSION_TAG="v$(date +%Y%m%d-%H%M%S)"
HEALTH_CHECK_URL="/api/health"

# ìƒ‰ìƒ ì¶œë ¥
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

log() { echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; }

# í™˜ê²½ ê²€ì¦
validate_environment() {
    log "í™˜ê²½ ê²€ì¦ ì¤‘..."
    
    # í•„ìˆ˜ ë„êµ¬ í™•ì¸
    for tool in gcloud docker jq; do
        if ! command -v "$tool" &> /dev/null; then
            error "$toolì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
            exit 1
        fi
    done
    
    # í™˜ê²½ ë³€ìˆ˜ í™•ì¸
    if [[ -z "${PROJECT_ID:-}" || -z "${REGION:-}" ]]; then
        error "PROJECT_IDì™€ REGION í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        exit 1
    fi
    
    # í˜„ì¬ í”„ë¡œì íŠ¸ í™•ì¸
    current_project=$(gcloud config get-value project 2>/dev/null || echo "")
    if [[ "$current_project" != "$PROJECT_ID" ]]; then
        warning "í˜„ì¬ í”„ë¡œì íŠ¸($current_project)ì™€ ì„¤ì •ëœ PROJECT_ID($PROJECT_ID)ê°€ ë‹¤ë¦…ë‹ˆë‹¤."
        gcloud config set project "$PROJECT_ID"
    fi
    
    success "í™˜ê²½ ê²€ì¦ ì™„ë£Œ"
}

# ì½”ë“œ í’ˆì§ˆ ê²€ì¦
validate_code_quality() {
    log "ì½”ë“œ í’ˆì§ˆ ê²€ì¦ ì¤‘..."
    
    # Dockerfile ê²€ì¦
    if [[ ! -f "Dockerfile" ]]; then
        error "Dockerfileì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        exit 1
    fi
    
    # ë³´ì•ˆ ìŠ¤ìº” (ì˜ˆ: hadolint)
    if command -v hadolint &> /dev/null; then
        hadolint Dockerfile || warning "Dockerfile ë¦°íŠ¸ ê²€ì‚¬ì—ì„œ ê²½ê³ ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
    fi
    
    # íŒ¨í‚¤ì§€ ì·¨ì•½ì  ê²€ì‚¬ (Node.js ì˜ˆì‹œ)
    if [[ -f "package.json" ]]; then
        npm audit --audit-level=high || warning "ë³´ì•ˆ ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤."
    fi
    
    success "ì½”ë“œ í’ˆì§ˆ ê²€ì¦ ì™„ë£Œ"
}

# ì´ë¯¸ì§€ ë¹Œë“œ ë° ìµœì í™”
build_and_optimize_image() {
    log "Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° ìµœì í™” ì¤‘..."
    
    local image_name="gcr.io/$PROJECT_ID/$SERVICE_NAME:$VERSION_TAG"
    local latest_image="gcr.io/$PROJECT_ID/$SERVICE_NAME:latest"
    
    # ë©€í‹°ìŠ¤í…Œì´ì§€ ë¹Œë“œ
    docker build \
        --target production \
        --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
        --build-arg VERSION="$VERSION_TAG" \
        --tag "$image_name" \
        --tag "$latest_image" \
        .
    
    # ì´ë¯¸ì§€ í¬ê¸° í™•ì¸
    local image_size=$(docker image inspect "$image_name" --format='{{.Size}}' | numfmt --to=iec)
    log "ë¹Œë“œëœ ì´ë¯¸ì§€ í¬ê¸°: $image_size"
    
    # ë³´ì•ˆ ìŠ¤ìº” (Trivy ì‚¬ìš©)
    if command -v trivy &> /dev/null; then
        trivy image --severity HIGH,CRITICAL "$image_name" || warning "ë³´ì•ˆ ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤."
    fi
    
    # ì´ë¯¸ì§€ í‘¸ì‹œ
    docker push "$image_name"
    docker push "$latest_image"
    
    success "ì´ë¯¸ì§€ ë¹Œë“œ ë° ë°°í¬ ì™„ë£Œ: $image_name"
    echo "$image_name"  # ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ë°˜í™˜
}

# ìŠ¤í…Œì´ì§• í™˜ê²½ ë°°í¬
deploy_to_staging() {
    local image_name="$1"
    log "ìŠ¤í…Œì´ì§• í™˜ê²½ì— ë°°í¬ ì¤‘..."
    
    local staging_service="${SERVICE_NAME}-staging"
    
    gcloud run deploy "$staging_service" \
        --image "$image_name" \
        --platform managed \
        --region "$REGION" \
        --service-account="cloudrun-sa@$PROJECT_ID.iam.gserviceaccount.com" \
        --memory="512Mi" \
        --cpu="1" \
        --concurrency="80" \
        --max-instances="10" \
        --min-instances="0" \
        --timeout="300" \
        --allow-unauthenticated \
        --set-env-vars="NODE_ENV=staging,LOG_LEVEL=debug" \
        --tag="staging-$VERSION_TAG" \
        --quiet
    
    local staging_url=$(gcloud run services describe "$staging_service" \
        --region="$REGION" --format="value(status.url)")
    
    success "ìŠ¤í…Œì´ì§• ë°°í¬ ì™„ë£Œ: $staging_url"
    echo "$staging_url"
}

# ìŠ¤í…Œì´ì§• í…ŒìŠ¤íŠ¸
test_staging_deployment() {
    local staging_url="$1"
    log "ìŠ¤í…Œì´ì§• í™˜ê²½ í…ŒìŠ¤íŠ¸ ì¤‘..."
    
    # í—¬ìŠ¤ì²´í¬
    local health_url="${staging_url}${HEALTH_CHECK_URL}"
    local max_attempts=30
    local attempt=1
    
    while [[ $attempt -le $max_attempts ]]; do
        if curl -sf "$health_url" > /dev/null; then
            success "í—¬ìŠ¤ì²´í¬ í†µê³¼ ($attempt/$max_attempts)"
            break
        fi
        
        if [[ $attempt -eq $max_attempts ]]; then
            error "í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨"
            exit 1
        fi
        
        sleep 10
        ((attempt++))
    done
    
    # ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
    local response=$(curl -s "$staging_url" | jq -r '.message // "No message"')
    if [[ "$response" == *"Hello"* ]]; then
        success "ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ í†µê³¼"
    else
        error "ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: $response"
        exit 1
    fi
    
    # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (ê°„ë‹¨í•œ ë¶€í•˜ í…ŒìŠ¤íŠ¸)
    log "ê°„ë‹¨í•œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘..."
    for i in {1..10}; do
        curl -s "$staging_url" > /dev/null &
    done
    wait
    
    success "ìŠ¤í…Œì´ì§• í…ŒìŠ¤íŠ¸ ì™„ë£Œ"
}

# í”„ë¡œë•ì…˜ ë°°í¬ (ì¹´ë‚˜ë¦¬/ë¸”ë£¨-ê·¸ë¦°)
deploy_to_production() {
    local image_name="$1"
    log "í”„ë¡œë•ì…˜ í™˜ê²½ì— ì¹´ë‚˜ë¦¬ ë°°í¬ ì¤‘..."
    
    # ìƒˆ ë¦¬ë¹„ì „ ë°°í¬ (íŠ¸ë˜í”½ 0%)
    gcloud run deploy "$SERVICE_NAME" \
        --image "$image_name" \
        --platform managed \
        --region "$REGION" \
        --service-account="cloudrun-sa@$PROJECT_ID.iam.gserviceaccount.com" \
        --vpc-connector="cloudrun-connector" \
        --vpc-egress="private-ranges-only" \
        --memory="1Gi" \
        --cpu="2" \
        --concurrency="100" \
        --max-instances="100" \
        --min-instances="2" \
        --timeout="300" \
        --cpu-throttling \
        --no-allow-unauthenticated \
        --set-env-vars="NODE_ENV=production,LOG_LEVEL=info" \
        --tag="canary-$VERSION_TAG" \
        --no-traffic \
        --quiet
    
    local prod_url=$(gcloud run services describe "$SERVICE_NAME" \
        --region="$REGION" --format="value(status.url)")
    
    success "í”„ë¡œë•ì…˜ ì¹´ë‚˜ë¦¬ ë°°í¬ ì™„ë£Œ (íŠ¸ë˜í”½ 0%): $prod_url"
    
    # ì¹´ë‚˜ë¦¬ í…ŒìŠ¤íŠ¸
    log "ì¹´ë‚˜ë¦¬ ë²„ì „ í…ŒìŠ¤íŠ¸ ì¤‘..."
    local canary_url="${prod_url}--canary-${VERSION_TAG}---${PROJECT_ID}.cloudfunctions.net"
    
    # ì¹´ë‚˜ë¦¬ í—¬ìŠ¤ì²´í¬
    if curl -sf "${canary_url}${HEALTH_CHECK_URL}" > /dev/null; then
        success "ì¹´ë‚˜ë¦¬ í—¬ìŠ¤ì²´í¬ í†µê³¼"
    else
        error "ì¹´ë‚˜ë¦¬ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨"
        exit 1
    fi
    
    # ì ì§„ì  íŠ¸ë˜í”½ ì¦ê°€
    local traffic_percentages=(10 25 50 100)
    
    for percentage in "${traffic_percentages[@]}"; do
        log "íŠ¸ë˜í”½ ${percentage}%ë¡œ ì¦ê°€ ì¤‘..."
        
        gcloud run services update-traffic "$SERVICE_NAME" \
            --region="$REGION" \
            --to-revisions="LATEST=$percentage" \
            --quiet
        
        # ëª¨ë‹ˆí„°ë§ ëŒ€ê¸° ì‹œê°„
        local wait_time=300  # 5ë¶„
        log "${wait_time}ì´ˆ ë™ì•ˆ ëª¨ë‹ˆí„°ë§ ì¤‘..."
        sleep "$wait_time"
        
        # ì—ëŸ¬ìœ¨ ì²´í¬ (ê°„ë‹¨í•œ ì˜ˆì‹œ)
        local error_count=$(gcloud logging read "resource.type=cloud_run_revision AND severity>=ERROR" \
            --limit=10 --format="value(timestamp)" | wc -l)
        
        if [[ $error_count -gt 5 ]]; then
            error "ì—ëŸ¬ìœ¨ì´ ë†’ìŠµë‹ˆë‹¤. ë¡¤ë°±ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."
            rollback_deployment
            exit 1
        fi
        
        success "íŠ¸ë˜í”½ ${percentage}% ì•ˆì •í™” ì™„ë£Œ"
    done
    
    success "í”„ë¡œë•ì…˜ ë°°í¬ ì™„ë£Œ!"
    echo "$prod_url"
}

# ë¡¤ë°± ê¸°ëŠ¥
rollback_deployment() {
    log "ì´ì „ ë²„ì „ìœ¼ë¡œ ë¡¤ë°± ì¤‘..."
    
    gcloud run services update-traffic "$SERVICE_NAME" \
        --region="$REGION" \
        --to-revisions="LATEST=0" \
        --quiet
    
    warning "ë¡¤ë°±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
}

# ë°°í¬ í›„ ëª¨ë‹ˆí„°ë§ ì„¤ì •
setup_monitoring() {
    log "ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì„¤ì • ì¤‘..."
    
    # ì»¤ìŠ¤í…€ ëŒ€ì‹œë³´ë“œ ìƒì„±ì„ ìœ„í•œ ì„¤ì • íŒŒì¼
    cat > monitoring-config.json << EOF
{
  "displayName": "${SERVICE_NAME} Dashboard",
  "mosaicLayout": {
    "tiles": [
      {
        "width": 6,
        "height": 4,
        "widget": {
          "title": "Request Count",
          "xyChart": {
            "dataSets": [{
              "timeSeriesQuery": {
                "timeSeriesFilter": {
                  "filter": "resource.type=\"cloud_run_revision\" resource.label.service_name=\"${SERVICE_NAME}\"",
                  "aggregation": {
                    "alignmentPeriod": "60s",
                    "perSeriesAligner": "ALIGN_RATE"
                  }
                }
              }
            }]
          }
        }
      }
    ]
  }
}
EOF
    
    success "ëª¨ë‹ˆí„°ë§ ì„¤ì • ì™„ë£Œ"
}

# ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜
main() {
    log "ğŸš€ í”„ë¡œë•ì…˜ ë°°í¬ ì‹œì‘: $SERVICE_NAME ($VERSION_TAG)"
    
    validate_environment
    validate_code_quality
    
    local image_name
    image_name=$(build_and_optimize_image)
    
    local staging_url
    staging_url=$(deploy_to_staging "$image_name")
    test_staging_deployment "$staging_url"
    
    # ë°°í¬ ìŠ¹ì¸ ìš”ì²­
    echo ""
    warning "ìŠ¤í…Œì´ì§• í…ŒìŠ¤íŠ¸ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
    read -p "í”„ë¡œë•ì…˜ ë°°í¬ë¥¼ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "ë°°í¬ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤."
        exit 0
    fi
    
    local prod_url
    prod_url=$(deploy_to_production "$image_name")
    setup_monitoring
    
    success "ğŸ‰ ëª¨ë“  ë°°í¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!"
    echo ""
    echo "ğŸ“Š ë°°í¬ ìš”ì•½:"
    echo "  Service: $SERVICE_NAME"
    echo "  Version: $VERSION_TAG"
    echo "  Staging URL: $staging_url"
    echo "  Production URL: $prod_url"
    echo "  Image: $image_name"
    
    log "ë°°í¬ ë¡œê·¸ëŠ” Google Cloud Consoleì—ì„œ í™•ì¸í•˜ì„¸ìš”."
}

# ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
main "$@"
```

---

## ğŸ“š ì •ë¦¬ ë° ë‹¤ìŒ ë‹¨ê³„

### â­ í•µì‹¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

#### ğŸ“‹ ë°°í¬ ì „ í™•ì¸ì‚¬í•­

> [!tip] í”„ë¡œë•ì…˜ ë°°í¬ ì²´í¬ë¦¬ìŠ¤íŠ¸
> 1. **í™˜ê²½ ì„¤ì •**
>    - [ ] gcloud CLI ì„¤ì¹˜ ë° ì¸ì¦
>    - [ ] Docker ì„¤ì¹˜ ë° ì„¤ì •
>    - [ ] í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
>    - [ ] IAM ê¶Œí•œ í™•ì¸
> 
> 2. **ë³´ì•ˆ ì„¤ì •**
>    - [ ] ì„œë¹„ìŠ¤ ê³„ì • ìƒì„±
>    - [ ] ìµœì†Œ ê¶Œí•œ ë¶€ì—¬
>    - [ ] Secret Manager ì„¤ì •
>    - [ ] VPC ì—°ê²° (í•„ìš”ì‹œ)
> 
> 3. **ì• í”Œë¦¬ì¼€ì´ì…˜ ì¤€ë¹„**
>    - [ ] Dockerfile ìµœì í™”
>    - [ ] í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸
>    - [ ] ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§ ì„¤ì •
>    - [ ] í™˜ê²½ë³„ ì„¤ì • ë¶„ë¦¬

#### ğŸ“Š ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œë¼ì¸

| í•­ëª© | ê°œë°œí™˜ê²½ | í”„ë¡œë•ì…˜í™˜ê²½ |
|------|----------|-------------|
| ë©”ëª¨ë¦¬ | 512Mi | 1Gi+ |
| CPU | 1 | 2+ |
| ìµœì†Œ ì¸ìŠ¤í„´ìŠ¤ | 0 | 1-2 |
| ìµœëŒ€ ì¸ìŠ¤í„´ìŠ¤ | 10 | 100+ |
| ë™ì‹œì„± | 80 | 100+ |
| íƒ€ì„ì•„ì›ƒ | 300ì´ˆ | 300ì´ˆ |

### ğŸ’¡ íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ

#### ğŸ“‹ ìì£¼ ë°œìƒí•˜ëŠ” ë¬¸ì œë“¤

> [!example] ì¼ë°˜ì ì¸ ë¬¸ì œ í•´ê²°
> **Cold Start ë¬¸ì œ**:
> ```bash
> # ìµœì†Œ ì¸ìŠ¤í„´ìŠ¤ ì„¤ì •ìœ¼ë¡œ í•´ê²°
> --min-instances=1
> ```
> 
> **ë©”ëª¨ë¦¬ ë¶€ì¡±**:
> ```bash
> # ë©”ëª¨ë¦¬ ì¦ê°€
> --memory=1Gi
> ```
> 
> **ê¶Œí•œ ì˜¤ë¥˜**:
> ```bash
> # ì„œë¹„ìŠ¤ ê³„ì • ê¶Œí•œ í™•ì¸
> gcloud iam service-accounts get-iam-policy SERVICE_ACCOUNT_EMAIL
> ```
> 
> **ë„¤íŠ¸ì›Œí‚¹ ë¬¸ì œ**:
> ```bash
> # VPC ì—°ê²° ìƒíƒœ í™•ì¸
> gcloud compute networks vpc-access connectors describe CONNECTOR_NAME --region=REGION
> ```

### ğŸš€ ë‹¤ìŒ ë‹¨ê³„ í•™ìŠµ ë¡œë“œë§µ

1. **ê³ ê¸‰ ì£¼ì œë“¤**
   - Cloud Run Jobs (ë°°ì¹˜ ì²˜ë¦¬)
   - Multi-region ë°°í¬
   - íŠ¸ë˜í”½ ë¶„í•  ê³ ê¸‰ íŒ¨í„´
   - ì»¤ìŠ¤í…€ ë„ë©”ì¸ ë° SSL

2. **í†µí•© ì‹œë‚˜ë¦¬ì˜¤**
   - Cloud SQL ì—°ê²°
   - Pub/Sub ì´ë²¤íŠ¸ ì²˜ë¦¬
   - Cloud Storage íŒŒì¼ ì²˜ë¦¬
   - BigQuery ë°ì´í„° ë¶„ì„

3. **DevOps ê³ ë„í™”**
   - Terraformì„ ì´ìš©í•œ IaC
   - Skaffold ê°œë°œ ì›Œí¬í”Œë¡œìš°
   - GitOps with Cloud Build
   - ë©€í‹° í™˜ê²½ ê´€ë¦¬

> [!tip] ë§ˆì§€ë§‰ ì¡°ì–¸
> Cloud Runì€ ì„œë²„ë¦¬ìŠ¤ì˜ ë‹¨ìˆœí•¨ê³¼ ì»¨í…Œì´ë„ˆì˜ ìœ ì—°í•¨ì„ ëª¨ë‘ ì œê³µí•˜ëŠ” ê°•ë ¥í•œ í”Œë«í¼ì…ë‹ˆë‹¤. ì‘ì€ í”„ë¡œì íŠ¸ë¶€í„° ì‹œì‘í•˜ì—¬ ì ì§„ì ìœ¼ë¡œ ê¸°ëŠ¥ì„ í™•ì¥í•´ë‚˜ê°€ëŠ” ê²ƒì´ ì„±ê³µì˜ ì—´ì‡ ì…ë‹ˆë‹¤.